
build/arm_tiny.elf:     file format elf64-littleaarch64
build/arm_tiny.elf
architecture: aarch64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000040082098

Program Header:
    LOAD off    0x0000000000010000 vaddr 0x0000000040080000 paddr 0x0000000040080000 align 2**16
         filesz 0x00000000000027cc memsz 0x000000000000d000 flags rwx
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
private flags = 0x0:

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         000020c8  0000000040080000  0000000040080000  00010000  2**11
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000212  00000000400820c8  00000000400820c8  000120c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .eh_frame     000004ec  00000000400822e0  00000000400822e0  000122e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000a000  0000000040083000  0000000040083000  000127cc  2**12
                  ALLOC
  4 .debug_info   00000fa7  0000000000000000  0000000000000000  000127cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_abbrev 00000736  0000000000000000  0000000000000000  00013773  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000170  0000000000000000  0000000000000000  00013eb0  2**4
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_line   0000074c  0000000000000000  0000000000000000  00014020  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_str    00000484  0000000000000000  0000000000000000  0001476c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_line_str 0000013d  0000000000000000  0000000000000000  00014bf0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000045  0000000000000000  0000000000000000  00014d2d  2**0
                  CONTENTS, READONLY
 11 .debug_rnglists 0000002d  0000000000000000  0000000000000000  00014d72  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
0000000040080000 l    d  .text	0000000000000000 .text
00000000400820c8 l    d  .rodata	0000000000000000 .rodata
00000000400822e0 l    d  .eh_frame	0000000000000000 .eh_frame
0000000040083000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .debug_line_str	0000000000000000 .debug_line_str
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 l    d  .debug_rnglists	0000000000000000 .debug_rnglists
0000000000000000 l    df *ABS*	0000000000000000 gicv2.c
0000000040080000 l     F .text	0000000000000018 read32
0000000040080018 l     F .text	0000000000000024 write32
0000000000000000 l    df *ABS*	0000000000000000 handle.c
0000000040080518 l     F .text	0000000000000018 read_esr_el1
0000000000000000 l    df *ABS*	0000000000000000 main.c
0000000040080744 l     F .text	0000000000000018 read32
000000004008075c l     F .text	0000000000000024 write32
0000000040084008 l     O .bss	0000000000000004 count
0000000000000000 l    df *ABS*	0000000000000000 spin_lock.c
0000000000000000 l    df *ABS*	0000000000000000 tiny_io.c
000000004008087c l     F .text	000000000000001c spinlock_init
0000000000000000 l    df *ABS*	0000000000000000 exception.o
0000000000000000 l    df *ABS*	0000000000000000 spinlock.o
0000000000000000 l    df *ABS*	0000000000000000 startup.o
0000000040080924 g     F .text	0000000000000028 info
0000000040080720 g     F .text	0000000000000024 handle_init
0000000040083008 g     O .bss	0000000000001000 g_handler_vec
0000000040080170 g     F .text	0000000000000030 gicc_init
0000000040081800 g       .text	0000000000000000 exception_vector_base
00000000400801fc g     F .text	0000000000000028 gic_write_dir
000000004008205c g       .text	0000000000000000 spin_trylock
0000000040084010 g     O .bss	0000000000000004 lock
0000000040080780 g     F .text	0000000000000068 timer_gic_init
00000000400807e8 g     F .text	0000000000000054 timer_handler
00000000400808e0 g     F .text	0000000000000044 uart_putstr
0000000040080638 g     F .text	000000000000005c handle_irq_exception
0000000040080694 g     F .text	0000000000000018 invalid_exception
00000000400806e0 g     F .text	0000000000000040 interrupt_init
0000000040080358 g     F .text	0000000000000078 gic_disable_int
0000000040080974 g     F .text	0000000000000028 debug
0000000040081068 g     F .text	0000000000000020 tiny_hello
000000004008003c g     F .text	00000000000000ac gic_test_init
00000000400803d0 g     F .text	0000000000000088 gic_get_enable
000000004008083c g     F .text	0000000000000040 kernel_main
0000000040085000 g       .bss	0000000000000000 _stack_top
0000000040083000 g     O .bss	0000000000000004 _gicv2
00000000400800e8 g     F .text	0000000000000088 gic_init
0000000040080498 g     F .text	0000000000000040 gic_set_ipriority
0000000040082098 g       .text	0000000000000000 _start
00000000400804d8 g     F .text	0000000000000040 gic_set_icenabler
000000004008099c g     F .text	00000000000001c8 int_to_str
0000000040080458 g     F .text	0000000000000040 gic_set_isenabler
000000004008055c g     F .text	00000000000000dc handle_sync_exception
00000000400801a0 g     F .text	000000000000001c gic_read_iar
000000004008028c g     F .text	00000000000000cc gic_enable_int
0000000040080ed0 g     F .text	0000000000000198 tiny_printf
00000000400806ac g     F .text	0000000000000034 cntp_handler
0000000040080898 g     F .text	0000000000000020 tiny_io_init
0000000040082084 g       .text	0000000000000000 spin_unlock
00000000400801bc g     F .text	0000000000000018 gic_iar_irqnr
0000000040082040 g       .text	0000000000000000 spin_lock
00000000400801d4 g     F .text	0000000000000028 gic_write_eoir
0000000040080224 g     F .text	0000000000000040 gic_ipi_send_single
000000004008094c g     F .text	0000000000000028 warn
0000000040080b64 g     F .text	000000000000036c tiny_vsnprintf
00000000400808b8 g     F .text	0000000000000028 uart_putchar
0000000040080264 g     F .text	0000000000000028 cpu_num
0000000040080530 g     F .text	000000000000002c irq_handle_register



Disassembly of section .text:

0000000040080000 <read32>:
// gicd g0, g1  gicc enable
void gic_init(void)
{
    _gicv2.irq_nr = GICD_TYPER_IRQS(read32((void *)GICD_TYPER));
    if (_gicv2.irq_nr > 1020)
    {
    40080000:	d10043ff 	sub	sp, sp, #0x10
    40080004:	f90007e0 	str	x0, [sp, #8]
        _gicv2.irq_nr = 1020;
    40080008:	f94007e0 	ldr	x0, [sp, #8]
    4008000c:	b9400000 	ldr	w0, [x0]
    }
    40080010:	910043ff 	add	sp, sp, #0x10
    40080014:	d65f03c0 	ret

0000000040080018 <write32>:

    write32(GICD_CTRL_ENABLE_GROUP0 | GICD_CTRL_ENABLE_GROUP1, (void *)GICD_CTLR);
    40080018:	d10043ff 	sub	sp, sp, #0x10
    4008001c:	b9000fe0 	str	w0, [sp, #12]
    40080020:	f90003e1 	str	x1, [sp]

    40080024:	f94003e0 	ldr	x0, [sp]
    40080028:	b9400fe1 	ldr	w1, [sp, #12]
    4008002c:	b9000001 	str	w1, [x0]
    // 允许所有优先级的中断
    40080030:	d503201f 	nop
    40080034:	910043ff 	add	sp, sp, #0x10
    40080038:	d65f03c0 	ret

000000004008003c <gic_test_init>:
{
    4008003c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080040:	910003fd 	mov	x29, sp
    tiny_printf("[guest]     gicd enable %s\n", read32((void *)GICD_CTLR) ? "ok" : "error");
    40080044:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    40080048:	97ffffee 	bl	40080000 <read32>
    4008004c:	7100001f 	cmp	w0, #0x0
    40080050:	54000080 	b.eq	40080060 <gic_test_init+0x24>  // b.none
    40080054:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080058:	91032000 	add	x0, x0, #0xc8
    4008005c:	14000003 	b	40080068 <gic_test_init+0x2c>
    40080060:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080064:	91034000 	add	x0, x0, #0xd0
    40080068:	aa0003e1 	mov	x1, x0
    4008006c:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080070:	91036000 	add	x0, x0, #0xd8
    40080074:	94000397 	bl	40080ed0 <tiny_printf>
    tiny_printf("[guest]     gicc enable %s\n", read32((void *)GICC_CTLR) ? "ok" : "error");
    40080078:	d2a10020 	mov	x0, #0x8010000             	// #134283264
    4008007c:	97ffffe1 	bl	40080000 <read32>
    40080080:	7100001f 	cmp	w0, #0x0
    40080084:	54000080 	b.eq	40080094 <gic_test_init+0x58>  // b.none
    40080088:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    4008008c:	91032000 	add	x0, x0, #0xc8
    40080090:	14000003 	b	4008009c <gic_test_init+0x60>
    40080094:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080098:	91034000 	add	x0, x0, #0xd0
    4008009c:	aa0003e1 	mov	x1, x0
    400800a0:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400800a4:	9103e000 	add	x0, x0, #0xf8
    400800a8:	9400038a 	bl	40080ed0 <tiny_printf>
    tiny_printf("[guest]     irq numbers: %d\n", _gicv2.irq_nr);
    400800ac:	f0000000 	adrp	x0, 40083000 <_gicv2>
    400800b0:	91000000 	add	x0, x0, #0x0
    400800b4:	b9400000 	ldr	w0, [x0]
    400800b8:	2a0003e1 	mov	w1, w0
    400800bc:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400800c0:	91046000 	add	x0, x0, #0x118
    400800c4:	94000383 	bl	40080ed0 <tiny_printf>
    tiny_printf("[guest]     cpu num: %d\n", cpu_num());
    400800c8:	94000067 	bl	40080264 <cpu_num>
    400800cc:	2a0003e1 	mov	w1, w0
    400800d0:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400800d4:	9104e000 	add	x0, x0, #0x138
    400800d8:	9400037e 	bl	40080ed0 <tiny_printf>
}
    400800dc:	d503201f 	nop
    400800e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400800e4:	d65f03c0 	ret

00000000400800e8 <gic_init>:
{
    400800e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400800ec:	910003fd 	mov	x29, sp
    _gicv2.irq_nr = GICD_TYPER_IRQS(read32((void *)GICD_TYPER));
    400800f0:	d2800080 	mov	x0, #0x4                   	// #4
    400800f4:	f2a10000 	movk	x0, #0x800, lsl #16
    400800f8:	97ffffc2 	bl	40080000 <read32>
    400800fc:	12001000 	and	w0, w0, #0x1f
    40080100:	11000400 	add	w0, w0, #0x1
    40080104:	531b6801 	lsl	w1, w0, #5
    40080108:	f0000000 	adrp	x0, 40083000 <_gicv2>
    4008010c:	91000000 	add	x0, x0, #0x0
    40080110:	b9000001 	str	w1, [x0]
    if (_gicv2.irq_nr > 1020)
    40080114:	f0000000 	adrp	x0, 40083000 <_gicv2>
    40080118:	91000000 	add	x0, x0, #0x0
    4008011c:	b9400000 	ldr	w0, [x0]
    40080120:	710ff01f 	cmp	w0, #0x3fc
    40080124:	540000a9 	b.ls	40080138 <gic_init+0x50>  // b.plast
        _gicv2.irq_nr = 1020;
    40080128:	f0000000 	adrp	x0, 40083000 <_gicv2>
    4008012c:	91000000 	add	x0, x0, #0x0
    40080130:	52807f81 	mov	w1, #0x3fc                 	// #1020
    40080134:	b9000001 	str	w1, [x0]
    write32(GICD_CTRL_ENABLE_GROUP0 | GICD_CTRL_ENABLE_GROUP1, (void *)GICD_CTLR);
    40080138:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4008013c:	52800060 	mov	w0, #0x3                   	// #3
    40080140:	97ffffb6 	bl	40080018 <write32>
    write32(0xff - 7, (void *)GICC_PMR);
    40080144:	d2800081 	mov	x1, #0x4                   	// #4
    40080148:	f2a10021 	movk	x1, #0x801, lsl #16
    4008014c:	52801f00 	mov	w0, #0xf8                  	// #248
    40080150:	97ffffb2 	bl	40080018 <write32>
    write32(GICC_CTRL_ENABLE | (1 << 9), (void *)GICC_CTLR);
    40080154:	d2a10021 	mov	x1, #0x8010000             	// #134283264
    40080158:	52804020 	mov	w0, #0x201                 	// #513
    4008015c:	97ffffaf 	bl	40080018 <write32>

    gic_test_init();
    40080160:	97ffffb7 	bl	4008003c <gic_test_init>
}
    40080164:	d503201f 	nop
    40080168:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4008016c:	d65f03c0 	ret

0000000040080170 <gicc_init>:

void gicc_init()
{
    40080170:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080174:	910003fd 	mov	x29, sp
    // 允许所有优先级的中断
    write32(0xff - 7, (void *)GICC_PMR);
    40080178:	d2800081 	mov	x1, #0x4                   	// #4
    4008017c:	f2a10021 	movk	x1, #0x801, lsl #16
    40080180:	52801f00 	mov	w0, #0xf8                  	// #248
    40080184:	97ffffa5 	bl	40080018 <write32>
    write32(GICC_CTRL_ENABLE, (void *)GICC_CTLR);
    40080188:	d2a10021 	mov	x1, #0x8010000             	// #134283264
    4008018c:	52800020 	mov	w0, #0x1                   	// #1
    40080190:	97ffffa2 	bl	40080018 <write32>
}
    40080194:	d503201f 	nop
    40080198:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4008019c:	d65f03c0 	ret

00000000400801a0 <gic_read_iar>:

// get iar
uint32_t gic_read_iar(void)
{
    400801a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400801a4:	910003fd 	mov	x29, sp
    return read32((void *)GICC_IAR);
    400801a8:	d2800180 	mov	x0, #0xc                   	// #12
    400801ac:	f2a10020 	movk	x0, #0x801, lsl #16
    400801b0:	97ffff94 	bl	40080000 <read32>
}
    400801b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400801b8:	d65f03c0 	ret

00000000400801bc <gic_iar_irqnr>:

// iar to vector
uint32_t gic_iar_irqnr(uint32_t iar)
{
    400801bc:	d10043ff 	sub	sp, sp, #0x10
    400801c0:	b9000fe0 	str	w0, [sp, #12]
    return iar & GICC_IAR_INT_ID_MASK;
    400801c4:	b9400fe0 	ldr	w0, [sp, #12]
    400801c8:	12002400 	and	w0, w0, #0x3ff
}
    400801cc:	910043ff 	add	sp, sp, #0x10
    400801d0:	d65f03c0 	ret

00000000400801d4 <gic_write_eoir>:

void gic_write_eoir(uint32_t irqstat)
{
    400801d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400801d8:	910003fd 	mov	x29, sp
    400801dc:	b9001fe0 	str	w0, [sp, #28]
    write32(irqstat, (void *)GICC_EOIR);
    400801e0:	d2800201 	mov	x1, #0x10                  	// #16
    400801e4:	f2a10021 	movk	x1, #0x801, lsl #16
    400801e8:	b9401fe0 	ldr	w0, [sp, #28]
    400801ec:	97ffff8b 	bl	40080018 <write32>
}
    400801f0:	d503201f 	nop
    400801f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400801f8:	d65f03c0 	ret

00000000400801fc <gic_write_dir>:

void gic_write_dir(uint32_t irqstat)
{
    400801fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080200:	910003fd 	mov	x29, sp
    40080204:	b9001fe0 	str	w0, [sp, #28]
    write32(irqstat, (void *)GICC_DIR);
    40080208:	d2820001 	mov	x1, #0x1000                	// #4096
    4008020c:	f2a10021 	movk	x1, #0x801, lsl #16
    40080210:	b9401fe0 	ldr	w0, [sp, #28]
    40080214:	97ffff81 	bl	40080018 <write32>
}
    40080218:	d503201f 	nop
    4008021c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080220:	d65f03c0 	ret

0000000040080224 <gic_ipi_send_single>:

// 发送给特定的核（某个核）
void gic_ipi_send_single(int irq, int cpu)
{
    40080224:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080228:	910003fd 	mov	x29, sp
    4008022c:	b9001fe0 	str	w0, [sp, #28]
    40080230:	b9001be1 	str	w1, [sp, #24]
    // assert(cpu < 8);
    // assert(irq < 16);
    write32(1 << (cpu + 16) | irq, (void *)GICD_SGIR);
    40080234:	b9401be0 	ldr	w0, [sp, #24]
    40080238:	11004000 	add	w0, w0, #0x10
    4008023c:	52800021 	mov	w1, #0x1                   	// #1
    40080240:	1ac02021 	lsl	w1, w1, w0
    40080244:	b9401fe0 	ldr	w0, [sp, #28]
    40080248:	2a000020 	orr	w0, w1, w0
    4008024c:	d281e001 	mov	x1, #0xf00                 	// #3840
    40080250:	f2a10001 	movk	x1, #0x800, lsl #16
    40080254:	97ffff71 	bl	40080018 <write32>
}
    40080258:	d503201f 	nop
    4008025c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080260:	d65f03c0 	ret

0000000040080264 <cpu_num>:

// The number of implemented CPU interfaces.
uint32_t cpu_num(void)
{
    40080264:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080268:	910003fd 	mov	x29, sp
    return GICD_TYPER_CPU_NUM(read32((void *)GICD_TYPER));
    4008026c:	d2800080 	mov	x0, #0x4                   	// #4
    40080270:	f2a10000 	movk	x0, #0x800, lsl #16
    40080274:	97ffff63 	bl	40080000 <read32>
    40080278:	53057c00 	lsr	w0, w0, #5
    4008027c:	12000800 	and	w0, w0, #0x7
    40080280:	11000400 	add	w0, w0, #0x1
}
    40080284:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40080288:	d65f03c0 	ret

000000004008028c <gic_enable_int>:

// Enables the given interrupt.
void gic_enable_int(int vector, int pri)
{
    4008028c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40080290:	910003fd 	mov	x29, sp
    40080294:	b9001fe0 	str	w0, [sp, #28]
    40080298:	b9001be1 	str	w1, [sp, #24]
    int reg = vector >> 5;                     //  vec / 32
    4008029c:	b9401fe0 	ldr	w0, [sp, #28]
    400802a0:	13057c00 	asr	w0, w0, #5
    400802a4:	b9002fe0 	str	w0, [sp, #44]
    int mask = 1 << (vector & ((1 << 5) - 1)); //  vec % 32
    400802a8:	b9401fe0 	ldr	w0, [sp, #28]
    400802ac:	12001000 	and	w0, w0, #0x1f
    400802b0:	52800021 	mov	w1, #0x1                   	// #1
    400802b4:	1ac02020 	lsl	w0, w1, w0
    400802b8:	b9002be0 	str	w0, [sp, #40]
    tiny_printf("[guest] set enable: reg: %d, mask: 0x%x\n", reg, mask);
    400802bc:	b9402be2 	ldr	w2, [sp, #40]
    400802c0:	b9402fe1 	ldr	w1, [sp, #44]
    400802c4:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400802c8:	91056000 	add	x0, x0, #0x158
    400802cc:	94000301 	bl	40080ed0 <tiny_printf>

    write32(mask, (void *)(uint64_t)GICD_ISENABLER(reg));
    400802d0:	b9402be2 	ldr	w2, [sp, #40]
    400802d4:	b9402fe1 	ldr	w1, [sp, #44]
    400802d8:	52800800 	mov	w0, #0x40                  	// #64
    400802dc:	72a04000 	movk	w0, #0x200, lsl #16
    400802e0:	0b000020 	add	w0, w1, w0
    400802e4:	531e7400 	lsl	w0, w0, #2
    400802e8:	93407c00 	sxtw	x0, w0
    400802ec:	aa0003e1 	mov	x1, x0
    400802f0:	2a0203e0 	mov	w0, w2
    400802f4:	97ffff49 	bl	40080018 <write32>

    int n = vector >> 2;
    400802f8:	b9401fe0 	ldr	w0, [sp, #28]
    400802fc:	13027c00 	asr	w0, w0, #2
    40080300:	b90027e0 	str	w0, [sp, #36]
    int m = vector & ((1 << 2) - 1);
    40080304:	b9401fe0 	ldr	w0, [sp, #28]
    40080308:	12000400 	and	w0, w0, #0x3
    4008030c:	b90023e0 	str	w0, [sp, #32]
    write32((pri << 3) | (1 << 7), (void *)(uint64_t)(GICD_IPRIORITYR(n) + m));
    40080310:	b9401be0 	ldr	w0, [sp, #24]
    40080314:	531d7000 	lsl	w0, w0, #3
    40080318:	32190000 	orr	w0, w0, #0x80
    4008031c:	2a0003e2 	mov	w2, w0
    40080320:	b94027e1 	ldr	w1, [sp, #36]
    40080324:	52802000 	mov	w0, #0x100                 	// #256
    40080328:	72a04000 	movk	w0, #0x200, lsl #16
    4008032c:	0b000020 	add	w0, w1, w0
    40080330:	531e7401 	lsl	w1, w0, #2
    40080334:	b94023e0 	ldr	w0, [sp, #32]
    40080338:	0b000020 	add	w0, w1, w0
    4008033c:	93407c00 	sxtw	x0, w0
    40080340:	aa0003e1 	mov	x1, x0
    40080344:	2a0203e0 	mov	w0, w2
    40080348:	97ffff34 	bl	40080018 <write32>
}
    4008034c:	d503201f 	nop
    40080350:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40080354:	d65f03c0 	ret

0000000040080358 <gic_disable_int>:

// disables the given interrupt.
void gic_disable_int(int vector, int pri)
{
    40080358:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4008035c:	910003fd 	mov	x29, sp
    40080360:	b9001fe0 	str	w0, [sp, #28]
    40080364:	b9001be1 	str	w1, [sp, #24]
    int reg = vector >> 5;                     //  vec / 32
    40080368:	b9401fe0 	ldr	w0, [sp, #28]
    4008036c:	13057c00 	asr	w0, w0, #5
    40080370:	b9002fe0 	str	w0, [sp, #44]
    int mask = 1 << (vector & ((1 << 5) - 1)); //  vec % 32
    40080374:	b9401fe0 	ldr	w0, [sp, #28]
    40080378:	12001000 	and	w0, w0, #0x1f
    4008037c:	52800021 	mov	w1, #0x1                   	// #1
    40080380:	1ac02020 	lsl	w0, w1, w0
    40080384:	b9002be0 	str	w0, [sp, #40]
    tiny_printf("[guest] disable: reg: %d, mask: 0x%x\n", reg, mask);
    40080388:	b9402be2 	ldr	w2, [sp, #40]
    4008038c:	b9402fe1 	ldr	w1, [sp, #44]
    40080390:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080394:	91062000 	add	x0, x0, #0x188
    40080398:	940002ce 	bl	40080ed0 <tiny_printf>

    write32(mask, (void *)(uint64_t)GICD_ICENABLER(reg));
    4008039c:	b9402be2 	ldr	w2, [sp, #40]
    400803a0:	b9402fe1 	ldr	w1, [sp, #44]
    400803a4:	52800c00 	mov	w0, #0x60                  	// #96
    400803a8:	72a04000 	movk	w0, #0x200, lsl #16
    400803ac:	0b000020 	add	w0, w1, w0
    400803b0:	531e7400 	lsl	w0, w0, #2
    400803b4:	93407c00 	sxtw	x0, w0
    400803b8:	aa0003e1 	mov	x1, x0
    400803bc:	2a0203e0 	mov	w0, w2
    400803c0:	97ffff16 	bl	40080018 <write32>
}
    400803c4:	d503201f 	nop
    400803c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400803cc:	d65f03c0 	ret

00000000400803d0 <gic_get_enable>:

// check the given interrupt.
int gic_get_enable(int vector)
{
    400803d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400803d4:	910003fd 	mov	x29, sp
    400803d8:	b9001fe0 	str	w0, [sp, #28]
    int reg = vector >> 5;                     //  vec / 32
    400803dc:	b9401fe0 	ldr	w0, [sp, #28]
    400803e0:	13057c00 	asr	w0, w0, #5
    400803e4:	b9002fe0 	str	w0, [sp, #44]
    int mask = 1 << (vector & ((1 << 5) - 1)); //  vec % 32
    400803e8:	b9401fe0 	ldr	w0, [sp, #28]
    400803ec:	12001000 	and	w0, w0, #0x1f
    400803f0:	52800021 	mov	w1, #0x1                   	// #1
    400803f4:	1ac02020 	lsl	w0, w1, w0
    400803f8:	b9002be0 	str	w0, [sp, #40]

    uint32_t val = read32((void *)(uint64_t)GICD_ISENABLER(reg));
    400803fc:	b9402fe1 	ldr	w1, [sp, #44]
    40080400:	52800800 	mov	w0, #0x40                  	// #64
    40080404:	72a04000 	movk	w0, #0x200, lsl #16
    40080408:	0b000020 	add	w0, w1, w0
    4008040c:	531e7400 	lsl	w0, w0, #2
    40080410:	93407c00 	sxtw	x0, w0
    40080414:	97fffefb 	bl	40080000 <read32>
    40080418:	b90027e0 	str	w0, [sp, #36]

    tiny_printf("[guest] get enable: reg: %x, mask: %x, value: %x\n", reg, mask, val);
    4008041c:	b94027e3 	ldr	w3, [sp, #36]
    40080420:	b9402be2 	ldr	w2, [sp, #40]
    40080424:	b9402fe1 	ldr	w1, [sp, #44]
    40080428:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    4008042c:	9106c000 	add	x0, x0, #0x1b0
    40080430:	940002a8 	bl	40080ed0 <tiny_printf>
    return val & (mask != 0);
    40080434:	b9402be0 	ldr	w0, [sp, #40]
    40080438:	7100001f 	cmp	w0, #0x0
    4008043c:	1a9f07e0 	cset	w0, ne	// ne = any
    40080440:	12001c00 	and	w0, w0, #0xff
    40080444:	2a0003e1 	mov	w1, w0
    40080448:	b94027e0 	ldr	w0, [sp, #36]
    4008044c:	0a000020 	and	w0, w1, w0
}
    40080450:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40080454:	d65f03c0 	ret

0000000040080458 <gic_set_isenabler>:

void gic_set_isenabler(uint32_t n, uint32_t value)
{
    40080458:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4008045c:	910003fd 	mov	x29, sp
    40080460:	b9001fe0 	str	w0, [sp, #28]
    40080464:	b9001be1 	str	w1, [sp, #24]
    write32(value, (void *)(uint64_t)GICD_ISENABLER(n));
    40080468:	b9401fe1 	ldr	w1, [sp, #28]
    4008046c:	52800800 	mov	w0, #0x40                  	// #64
    40080470:	72a04000 	movk	w0, #0x200, lsl #16
    40080474:	0b000020 	add	w0, w1, w0
    40080478:	531e7400 	lsl	w0, w0, #2
    4008047c:	2a0003e0 	mov	w0, w0
    40080480:	aa0003e1 	mov	x1, x0
    40080484:	b9401be0 	ldr	w0, [sp, #24]
    40080488:	97fffee4 	bl	40080018 <write32>
}
    4008048c:	d503201f 	nop
    40080490:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080494:	d65f03c0 	ret

0000000040080498 <gic_set_ipriority>:

void gic_set_ipriority(uint32_t n, uint32_t value)
{
    40080498:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4008049c:	910003fd 	mov	x29, sp
    400804a0:	b9001fe0 	str	w0, [sp, #28]
    400804a4:	b9001be1 	str	w1, [sp, #24]
    write32(value, (void *)(uint64_t)GICD_IPRIORITYR(n));
    400804a8:	b9401fe1 	ldr	w1, [sp, #28]
    400804ac:	52802000 	mov	w0, #0x100                 	// #256
    400804b0:	72a04000 	movk	w0, #0x200, lsl #16
    400804b4:	0b000020 	add	w0, w1, w0
    400804b8:	531e7400 	lsl	w0, w0, #2
    400804bc:	2a0003e0 	mov	w0, w0
    400804c0:	aa0003e1 	mov	x1, x0
    400804c4:	b9401be0 	ldr	w0, [sp, #24]
    400804c8:	97fffed4 	bl	40080018 <write32>
}
    400804cc:	d503201f 	nop
    400804d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400804d4:	d65f03c0 	ret

00000000400804d8 <gic_set_icenabler>:

void gic_set_icenabler(uint32_t n, uint32_t value)
{
    400804d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400804dc:	910003fd 	mov	x29, sp
    400804e0:	b9001fe0 	str	w0, [sp, #28]
    400804e4:	b9001be1 	str	w1, [sp, #24]
    write32(value, (void *)(uint64_t)GICD_ICENABLER(n));
    400804e8:	b9401fe1 	ldr	w1, [sp, #28]
    400804ec:	52800c00 	mov	w0, #0x60                  	// #96
    400804f0:	72a04000 	movk	w0, #0x200, lsl #16
    400804f4:	0b000020 	add	w0, w1, w0
    400804f8:	531e7400 	lsl	w0, w0, #2
    400804fc:	2a0003e0 	mov	w0, w0
    40080500:	aa0003e1 	mov	x1, x0
    40080504:	b9401be0 	ldr	w0, [sp, #24]
    40080508:	97fffec4 	bl	40080018 <write32>
    4008050c:	d503201f 	nop
    40080510:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080514:	d65f03c0 	ret

0000000040080518 <read_esr_el1>:
    40080518:	d10043ff 	sub	sp, sp, #0x10
    4008051c:	d5385200 	mrs	x0, esr_el1
    40080520:	b9000fe0 	str	w0, [sp, #12]
    40080524:	b9400fe0 	ldr	w0, [sp, #12]
    40080528:	910043ff 	add	sp, sp, #0x10
    4008052c:	d65f03c0 	ret

0000000040080530 <irq_handle_register>:
{
    40080530:	d10043ff 	sub	sp, sp, #0x10
    40080534:	b9000fe0 	str	w0, [sp, #12]
    40080538:	f90003e1 	str	x1, [sp]
    g_handler_vec[vector] = h;
    4008053c:	f0000000 	adrp	x0, 40083000 <_gicv2>
    40080540:	91002000 	add	x0, x0, #0x8
    40080544:	b9800fe1 	ldrsw	x1, [sp, #12]
    40080548:	f94003e2 	ldr	x2, [sp]
    4008054c:	f8217802 	str	x2, [x0, x1, lsl #3]
}
    40080550:	d503201f 	nop
    40080554:	910043ff 	add	sp, sp, #0x10
    40080558:	d65f03c0 	ret

000000004008055c <handle_sync_exception>:
{
    4008055c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40080560:	910003fd 	mov	x29, sp
    40080564:	f9000fe0 	str	x0, [sp, #24]
    trap_frame_t *el1_ctx = (trap_frame_t *)stack_pointer;
    40080568:	f9400fe0 	ldr	x0, [sp, #24]
    4008056c:	f9002be0 	str	x0, [sp, #80]
    int el1_esr = read_esr_el1();
    40080570:	97ffffea 	bl	40080518 <read_esr_el1>
    40080574:	b9004fe0 	str	w0, [sp, #76]
    int ec = ((el1_esr >> 26) & 0b111111);
    40080578:	b9404fe0 	ldr	w0, [sp, #76]
    4008057c:	531a7c00 	lsr	w0, w0, #26
    40080580:	b9004be0 	str	w0, [sp, #72]
    tiny_printf("el1 esr: %d\n", el1_esr);
    40080584:	b9404fe1 	ldr	w1, [sp, #76]
    40080588:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    4008058c:	9107a000 	add	x0, x0, #0x1e8
    40080590:	94000250 	bl	40080ed0 <tiny_printf>
    tiny_printf("ec: %x\n", ec);
    40080594:	b9404be1 	ldr	w1, [sp, #72]
    40080598:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    4008059c:	9107e000 	add	x0, x0, #0x1f8
    400805a0:	9400024c 	bl	40080ed0 <tiny_printf>
    tiny_printf("This is handle_sync_exception: \n");
    400805a4:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400805a8:	91080000 	add	x0, x0, #0x200
    400805ac:	94000249 	bl	40080ed0 <tiny_printf>
    for (int i = 0; i < 31; i++)
    400805b0:	b9005fff 	str	wzr, [sp, #92]
    400805b4:	1400000d 	b	400805e8 <handle_sync_exception+0x8c>
        uint64_t value = el1_ctx->r[i];
    400805b8:	f9402be0 	ldr	x0, [sp, #80]
    400805bc:	b9805fe1 	ldrsw	x1, [sp, #92]
    400805c0:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    400805c4:	f90017e0 	str	x0, [sp, #40]
        tiny_printf("General-purpose register: %d, value: %x\n", i, value);
    400805c8:	f94017e2 	ldr	x2, [sp, #40]
    400805cc:	b9405fe1 	ldr	w1, [sp, #92]
    400805d0:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400805d4:	9108a000 	add	x0, x0, #0x228
    400805d8:	9400023e 	bl	40080ed0 <tiny_printf>
    for (int i = 0; i < 31; i++)
    400805dc:	b9405fe0 	ldr	w0, [sp, #92]
    400805e0:	11000400 	add	w0, w0, #0x1
    400805e4:	b9005fe0 	str	w0, [sp, #92]
    400805e8:	b9405fe0 	ldr	w0, [sp, #92]
    400805ec:	7100781f 	cmp	w0, #0x1e
    400805f0:	54fffe4d 	b.le	400805b8 <handle_sync_exception+0x5c>
    uint64_t elr_el1_value = el1_ctx->elr;
    400805f4:	f9402be0 	ldr	x0, [sp, #80]
    400805f8:	f9408000 	ldr	x0, [x0, #256]
    400805fc:	f90023e0 	str	x0, [sp, #64]
    uint64_t usp_value = el1_ctx->usp;
    40080600:	f9402be0 	ldr	x0, [sp, #80]
    40080604:	f9407c00 	ldr	x0, [x0, #248]
    40080608:	f9001fe0 	str	x0, [sp, #56]
    uint64_t spsr_value = el1_ctx->spsr;
    4008060c:	f9402be0 	ldr	x0, [sp, #80]
    40080610:	f9408400 	ldr	x0, [x0, #264]
    40080614:	f9001be0 	str	x0, [sp, #48]
    tiny_printf("usp: %x, elr: %x, spsr: %x\n", usp_value, elr_el1_value, spsr_value);
    40080618:	f9401be3 	ldr	x3, [sp, #48]
    4008061c:	f94023e2 	ldr	x2, [sp, #64]
    40080620:	f9401fe1 	ldr	x1, [sp, #56]
    40080624:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080628:	91096000 	add	x0, x0, #0x258
    4008062c:	94000229 	bl	40080ed0 <tiny_printf>
    while(1) ;
    40080630:	d503201f 	nop
    40080634:	17ffffff 	b	40080630 <handle_sync_exception+0xd4>

0000000040080638 <handle_irq_exception>:
{
    40080638:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4008063c:	910003fd 	mov	x29, sp
    40080640:	f9000fe0 	str	x0, [sp, #24]
    trap_frame_t *el1_ctx = (trap_frame_t *)stack_pointer;
    40080644:	f9400fe0 	ldr	x0, [sp, #24]
    40080648:	f90017e0 	str	x0, [sp, #40]
    int iar = gic_read_iar();
    4008064c:	97fffed5 	bl	400801a0 <gic_read_iar>
    40080650:	b90027e0 	str	w0, [sp, #36]
    int vector = gic_iar_irqnr(iar);
    40080654:	b94027e0 	ldr	w0, [sp, #36]
    40080658:	97fffed9 	bl	400801bc <gic_iar_irqnr>
    4008065c:	b90023e0 	str	w0, [sp, #32]
    g_handler_vec[vector]((uint64_t *)el1_ctx); // arg not use
    40080660:	f0000000 	adrp	x0, 40083000 <_gicv2>
    40080664:	91002000 	add	x0, x0, #0x8
    40080668:	b98023e1 	ldrsw	x1, [sp, #32]
    4008066c:	f8617801 	ldr	x1, [x0, x1, lsl #3]
    40080670:	f94017e0 	ldr	x0, [sp, #40]
    40080674:	d63f0020 	blr	x1
    gic_write_eoir(iar);
    40080678:	b94027e0 	ldr	w0, [sp, #36]
    4008067c:	97fffed6 	bl	400801d4 <gic_write_eoir>
    gic_write_dir(iar);
    40080680:	b94027e0 	ldr	w0, [sp, #36]
    40080684:	97fffede 	bl	400801fc <gic_write_dir>
}
    40080688:	d503201f 	nop
    4008068c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40080690:	d65f03c0 	ret

0000000040080694 <invalid_exception>:
{
    40080694:	d10083ff 	sub	sp, sp, #0x20
    40080698:	f9000fe0 	str	x0, [sp, #24]
    4008069c:	f9000be1 	str	x1, [sp, #16]
    400806a0:	f90007e2 	str	x2, [sp, #8]
    while (1)
    400806a4:	d503201f 	nop
    400806a8:	17ffffff 	b	400806a4 <invalid_exception+0x10>

00000000400806ac <cntp_handler>:
{
    400806ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400806b0:	910003fd 	mov	x29, sp
    400806b4:	f9000fe0 	str	x0, [sp, #24]
    asm volatile("msr CNTP_TVAL_EL0, %0" : : "r"(50000000));
    400806b8:	529e1000 	mov	w0, #0xf080                	// #61568
    400806bc:	72a05f40 	movk	w0, #0x2fa, lsl #16
    400806c0:	d51be200 	msr	cntp_tval_el0, x0
    tiny_printf("irq %d\n", TIMER);
    400806c4:	528003c1 	mov	w1, #0x1e                  	// #30
    400806c8:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    400806cc:	9109e000 	add	x0, x0, #0x278
    400806d0:	94000200 	bl	40080ed0 <tiny_printf>
}
    400806d4:	d503201f 	nop
    400806d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400806dc:	d65f03c0 	ret

00000000400806e0 <interrupt_init>:
{
    400806e0:	d10043ff 	sub	sp, sp, #0x10
    asm volatile("mrs %0, CurrentEL" : "=r" (cur_el));
    400806e4:	d5384240 	mrs	x0, currentel
    400806e8:	f90007e0 	str	x0, [sp, #8]
    if(cur_el == 0x8) {
    400806ec:	f94007e0 	ldr	x0, [sp, #8]
    400806f0:	f100201f 	cmp	x0, #0x8
    400806f4:	54000101 	b.ne	40080714 <interrupt_init+0x34>  // b.any
	    asm volatile("mrs %0, HCR_EL2" : "=r" (value));
    400806f8:	d53c1100 	mrs	x0, hcr_el2
    400806fc:	f90003e0 	str	x0, [sp]
        value |= (1<<4);
    40080700:	f94003e0 	ldr	x0, [sp]
    40080704:	b27c0000 	orr	x0, x0, #0x10
    40080708:	f90003e0 	str	x0, [sp]
	    asm volatile("msr HCR_EL2, %0" : : "r" (value));   
    4008070c:	f94003e0 	ldr	x0, [sp]
    40080710:	d51c1100 	msr	hcr_el2, x0
	return 0;
    40080714:	52800000 	mov	w0, #0x0                   	// #0
}
    40080718:	910043ff 	add	sp, sp, #0x10
    4008071c:	d65f03c0 	ret

0000000040080720 <handle_init>:
{
    40080720:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080724:	910003fd 	mov	x29, sp
    irq_handle_register(TIMER, cntp_handler);
    40080728:	90000000 	adrp	x0, 40080000 <read32>
    4008072c:	911ab001 	add	x1, x0, #0x6ac
    40080730:	528003c0 	mov	w0, #0x1e                  	// #30
    40080734:	97ffff7f 	bl	40080530 <irq_handle_register>
    40080738:	d503201f 	nop
    4008073c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40080740:	d65f03c0 	ret

0000000040080744 <read32>:

    uint32_t value;

    value = read32((void *)(uint32_t)GICD_ISENABLER(0));
    value |= (1 << 30);
    write32(value, (void *)(uint32_t)GICD_ISENABLER(0));
    40080744:	d10043ff 	sub	sp, sp, #0x10
    40080748:	f90007e0 	str	x0, [sp, #8]
}
    4008074c:	f94007e0 	ldr	x0, [sp, #8]
    40080750:	b9400000 	ldr	w0, [x0]

    40080754:	910043ff 	add	sp, sp, #0x10
    40080758:	d65f03c0 	ret

000000004008075c <write32>:
static int count = 0;
void timer_handler(uint64_t *)
    4008075c:	d10043ff 	sub	sp, sp, #0x10
    40080760:	b9000fe0 	str	w0, [sp, #12]
    40080764:	f90003e1 	str	x1, [sp]
{
    40080768:	f94003e0 	ldr	x0, [sp]
    4008076c:	b9400fe1 	ldr	w1, [sp, #12]
    40080770:	b9000001 	str	w1, [x0]
    asm volatile("msr CNTP_TVAL_EL0, %0" : : "r"(50000000));
    40080774:	d503201f 	nop
    40080778:	910043ff 	add	sp, sp, #0x10
    4008077c:	d65f03c0 	ret

0000000040080780 <timer_gic_init>:
{
    40080780:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080784:	910003fd 	mov	x29, sp
    write32(GICD_CTRL_ENABLE_GROUP0 | GICD_CTRL_ENABLE_GROUP1, (void *)GICD_CTLR);
    40080788:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4008078c:	52800060 	mov	w0, #0x3                   	// #3
    40080790:	97fffff3 	bl	4008075c <write32>
    write32(0xff - 7, (void *)GICC_PMR);
    40080794:	d2800081 	mov	x1, #0x4                   	// #4
    40080798:	f2a10021 	movk	x1, #0x801, lsl #16
    4008079c:	52801f00 	mov	w0, #0xf8                  	// #248
    400807a0:	97ffffef 	bl	4008075c <write32>
    write32(GICC_CTRL_ENABLE | (1 << 9), (void *)GICC_CTLR);
    400807a4:	d2a10021 	mov	x1, #0x8010000             	// #134283264
    400807a8:	52804020 	mov	w0, #0x201                 	// #513
    400807ac:	97ffffec 	bl	4008075c <write32>
    value = read32((void *)(uint32_t)GICD_ISENABLER(0));
    400807b0:	d2802000 	mov	x0, #0x100                 	// #256
    400807b4:	f2a10000 	movk	x0, #0x800, lsl #16
    400807b8:	97ffffe3 	bl	40080744 <read32>
    400807bc:	b9001fe0 	str	w0, [sp, #28]
    value |= (1 << 30);
    400807c0:	b9401fe0 	ldr	w0, [sp, #28]
    400807c4:	32020000 	orr	w0, w0, #0x40000000
    400807c8:	b9001fe0 	str	w0, [sp, #28]
    write32(value, (void *)(uint32_t)GICD_ISENABLER(0));
    400807cc:	d2802001 	mov	x1, #0x100                 	// #256
    400807d0:	f2a10001 	movk	x1, #0x800, lsl #16
    400807d4:	b9401fe0 	ldr	w0, [sp, #28]
    400807d8:	97ffffe1 	bl	4008075c <write32>
}
    400807dc:	d503201f 	nop
    400807e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400807e4:	d65f03c0 	ret

00000000400807e8 <timer_handler>:
{
    400807e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400807ec:	910003fd 	mov	x29, sp
    400807f0:	f9000fe0 	str	x0, [sp, #24]
    asm volatile("msr CNTP_TVAL_EL0, %0" : : "r"(50000000));
    400807f4:	529e1000 	mov	w0, #0xf080                	// #61568
    400807f8:	72a05f40 	movk	w0, #0x2fa, lsl #16
    400807fc:	d51be200 	msr	cntp_tval_el0, x0
    tiny_printf("irq %d, count %d\n", TIMER, count++);
    40080800:	90000020 	adrp	x0, 40084000 <g_handler_vec+0xff8>
    40080804:	91002000 	add	x0, x0, #0x8
    40080808:	b9400000 	ldr	w0, [x0]
    4008080c:	11000402 	add	w2, w0, #0x1
    40080810:	90000021 	adrp	x1, 40084000 <g_handler_vec+0xff8>
    40080814:	91002021 	add	x1, x1, #0x8
    40080818:	b9000022 	str	w2, [x1]
    4008081c:	2a0003e2 	mov	w2, w0
    40080820:	528003c1 	mov	w1, #0x1e                  	// #30
    40080824:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080828:	910a0000 	add	x0, x0, #0x280
    4008082c:	940001a9 	bl	40080ed0 <tiny_printf>
}
    40080830:	d503201f 	nop
    40080834:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080838:	d65f03c0 	ret

000000004008083c <kernel_main>:

int kernel_main(void)
{
    4008083c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080840:	910003fd 	mov	x29, sp
    tiny_hello();
    40080844:	94000209 	bl	40081068 <tiny_hello>

    // tiny_io_init();
    irq_handle_register(TIMER, timer_handler);
    40080848:	90000000 	adrp	x0, 40080000 <read32>
    4008084c:	911fa001 	add	x1, x0, #0x7e8
    40080850:	528003c0 	mov	w0, #0x1e                  	// #30
    40080854:	97ffff37 	bl	40080530 <irq_handle_register>
    // handle_init();
    // gic_init();
    timer_gic_init();
    40080858:	97ffffca 	bl	40080780 <timer_gic_init>
    // enable_interrupts();
    asm volatile("msr daifclr, #2" : : : "memory");
    4008085c:	d50342ff 	msr	daifclr, #0x2
    asm volatile("msr CNTP_TVAL_EL0, %0" : : "r"(50000000));
    40080860:	529e1000 	mov	w0, #0xf080                	// #61568
    40080864:	72a05f40 	movk	w0, #0x2fa, lsl #16
    40080868:	d51be200 	msr	cntp_tval_el0, x0
    asm volatile("msr CNTP_CTL_EL0, %0" : : "r"(1));
    4008086c:	52800020 	mov	w0, #0x1                   	// #1
    40080870:	d51be220 	msr	cntp_ctl_el0, x0

    while (1)
    40080874:	d503201f 	nop
    40080878:	17ffffff 	b	40080874 <kernel_main+0x38>

000000004008087c <spinlock_init>:
 * Author: Debin
 *
 * Description: This file contains the implementation of I/O functions for the ARM Tiny project.
 */

#include <stdarg.h>
    4008087c:	d10043ff 	sub	sp, sp, #0x10
    40080880:	f90007e0 	str	x0, [sp, #8]
#include <string.h>
    40080884:	f94007e0 	ldr	x0, [sp, #8]
    40080888:	b900001f 	str	wzr, [x0]
#include <stdlib.h>
    4008088c:	d503201f 	nop
    40080890:	910043ff 	add	sp, sp, #0x10
    40080894:	d65f03c0 	ret

0000000040080898 <tiny_io_init>:
#include <spin_lock.h>

spinlock_t lock;

void tiny_io_init()
{
    40080898:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4008089c:	910003fd 	mov	x29, sp
    spinlock_init(&lock);
    400808a0:	90000020 	adrp	x0, 40084000 <g_handler_vec+0xff8>
    400808a4:	91004000 	add	x0, x0, #0x10
    400808a8:	97fffff5 	bl	4008087c <spinlock_init>
}
    400808ac:	d503201f 	nop
    400808b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400808b4:	d65f03c0 	ret

00000000400808b8 <uart_putchar>:

void uart_putchar(char c)
{
    400808b8:	d10083ff 	sub	sp, sp, #0x20
    400808bc:	39003fe0 	strb	w0, [sp, #15]
    volatile unsigned int *const UART0DR = (unsigned int *)0x9000000;
    400808c0:	d2a12000 	mov	x0, #0x9000000             	// #150994944
    400808c4:	f9000fe0 	str	x0, [sp, #24]
    // spin_lock(&lock);
    *UART0DR = (unsigned int)c;
    400808c8:	39403fe1 	ldrb	w1, [sp, #15]
    400808cc:	f9400fe0 	ldr	x0, [sp, #24]
    400808d0:	b9000001 	str	w1, [x0]
    // spin_unlock(&lock);
}
    400808d4:	d503201f 	nop
    400808d8:	910083ff 	add	sp, sp, #0x20
    400808dc:	d65f03c0 	ret

00000000400808e0 <uart_putstr>:

void uart_putstr(const char *str)
{
    400808e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400808e4:	910003fd 	mov	x29, sp
    400808e8:	f9000fe0 	str	x0, [sp, #24]
    while (*str)
    400808ec:	14000006 	b	40080904 <uart_putstr+0x24>
    {
        uart_putchar(*str++);
    400808f0:	f9400fe0 	ldr	x0, [sp, #24]
    400808f4:	91000401 	add	x1, x0, #0x1
    400808f8:	f9000fe1 	str	x1, [sp, #24]
    400808fc:	39400000 	ldrb	w0, [x0]
    40080900:	97ffffee 	bl	400808b8 <uart_putchar>
    while (*str)
    40080904:	f9400fe0 	ldr	x0, [sp, #24]
    40080908:	39400000 	ldrb	w0, [x0]
    4008090c:	7100001f 	cmp	w0, #0x0
    40080910:	54ffff01 	b.ne	400808f0 <uart_putstr+0x10>  // b.any
    }
}
    40080914:	d503201f 	nop
    40080918:	d503201f 	nop
    4008091c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080920:	d65f03c0 	ret

0000000040080924 <info>:

void info(const char *info)
{
    40080924:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080928:	910003fd 	mov	x29, sp
    4008092c:	f9000fe0 	str	x0, [sp, #24]
    // ANSI 转义序列: "\033[32m" 设置绿色前景色, "\033[0m" 重置颜色
    tiny_printf("\033[32m%s\033[0m", info);
    40080930:	f9400fe1 	ldr	x1, [sp, #24]
    40080934:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080938:	910a6000 	add	x0, x0, #0x298
    4008093c:	94000165 	bl	40080ed0 <tiny_printf>
}
    40080940:	d503201f 	nop
    40080944:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080948:	d65f03c0 	ret

000000004008094c <warn>:

void warn(const char *info)
{
    4008094c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080950:	910003fd 	mov	x29, sp
    40080954:	f9000fe0 	str	x0, [sp, #24]
    // ANSI 转义序列: "\033[33m" 设置绿色前景色, "\033[0m" 重置颜色
    tiny_printf("\033[33m%s\033[0m", info);
    40080958:	f9400fe1 	ldr	x1, [sp, #24]
    4008095c:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080960:	910aa000 	add	x0, x0, #0x2a8
    40080964:	9400015b 	bl	40080ed0 <tiny_printf>
}
    40080968:	d503201f 	nop
    4008096c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080970:	d65f03c0 	ret

0000000040080974 <debug>:

void debug(const char *info)
{
    40080974:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080978:	910003fd 	mov	x29, sp
    4008097c:	f9000fe0 	str	x0, [sp, #24]
    // ANSI 转义序列: "\033[34m" 设置绿色前景色, "\033[0m" 重置颜色
    tiny_printf("\033[34m%s\033[0m", info);
    40080980:	f9400fe1 	ldr	x1, [sp, #24]
    40080984:	d0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40080988:	910ae000 	add	x0, x0, #0x2b8
    4008098c:	94000151 	bl	40080ed0 <tiny_printf>
}
    40080990:	d503201f 	nop
    40080994:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40080998:	d65f03c0 	ret

000000004008099c <int_to_str>:

int int_to_str(long num, char *str, int base)
{
    4008099c:	d10103ff 	sub	sp, sp, #0x40
    400809a0:	f9000fe0 	str	x0, [sp, #24]
    400809a4:	f9000be1 	str	x1, [sp, #16]
    400809a8:	b9000fe2 	str	w2, [sp, #12]
    if (base < 2 || base > 36)
    400809ac:	b9400fe0 	ldr	w0, [sp, #12]
    400809b0:	7100041f 	cmp	w0, #0x1
    400809b4:	5400008d 	b.le	400809c4 <int_to_str+0x28>
    400809b8:	b9400fe0 	ldr	w0, [sp, #12]
    400809bc:	7100901f 	cmp	w0, #0x24
    400809c0:	540000ad 	b.le	400809d4 <int_to_str+0x38>
    {
        str[0] = '\0';
    400809c4:	f9400be0 	ldr	x0, [sp, #16]
    400809c8:	3900001f 	strb	wzr, [x0]
        return 0;
    400809cc:	52800000 	mov	w0, #0x0                   	// #0
    400809d0:	14000063 	b	40080b5c <int_to_str+0x1c0>
    }

    int i = 0;
    400809d4:	b9003fff 	str	wzr, [sp, #60]
    int is_negative = (num < 0 && base == 10);
    400809d8:	f9400fe0 	ldr	x0, [sp, #24]
    400809dc:	f100001f 	cmp	x0, #0x0
    400809e0:	540000ca 	b.ge	400809f8 <int_to_str+0x5c>  // b.tcont
    400809e4:	b9400fe0 	ldr	w0, [sp, #12]
    400809e8:	7100281f 	cmp	w0, #0xa
    400809ec:	54000061 	b.ne	400809f8 <int_to_str+0x5c>  // b.any
    400809f0:	52800020 	mov	w0, #0x1                   	// #1
    400809f4:	14000002 	b	400809fc <int_to_str+0x60>
    400809f8:	52800000 	mov	w0, #0x0                   	// #0
    400809fc:	b90033e0 	str	w0, [sp, #48]

    if (is_negative)
    40080a00:	b94033e0 	ldr	w0, [sp, #48]
    40080a04:	7100001f 	cmp	w0, #0x0
    40080a08:	54000080 	b.eq	40080a18 <int_to_str+0x7c>  // b.none
    {
        num = -num;
    40080a0c:	f9400fe0 	ldr	x0, [sp, #24]
    40080a10:	cb0003e0 	neg	x0, x0
    40080a14:	f9000fe0 	str	x0, [sp, #24]
    }

    do
    {
        int rem = num % base;
    40080a18:	b9800fe1 	ldrsw	x1, [sp, #12]
    40080a1c:	f9400fe0 	ldr	x0, [sp, #24]
    40080a20:	9ac10c02 	sdiv	x2, x0, x1
    40080a24:	9b017c41 	mul	x1, x2, x1
    40080a28:	cb010000 	sub	x0, x0, x1
    40080a2c:	b9002fe0 	str	w0, [sp, #44]
        str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
    40080a30:	b9402fe0 	ldr	w0, [sp, #44]
    40080a34:	7100241f 	cmp	w0, #0x9
    40080a38:	540000cd 	b.le	40080a50 <int_to_str+0xb4>
    40080a3c:	b9402fe0 	ldr	w0, [sp, #44]
    40080a40:	12001c00 	and	w0, w0, #0xff
    40080a44:	11015c00 	add	w0, w0, #0x57
    40080a48:	12001c00 	and	w0, w0, #0xff
    40080a4c:	14000005 	b	40080a60 <int_to_str+0xc4>
    40080a50:	b9402fe0 	ldr	w0, [sp, #44]
    40080a54:	12001c00 	and	w0, w0, #0xff
    40080a58:	1100c000 	add	w0, w0, #0x30
    40080a5c:	12001c00 	and	w0, w0, #0xff
    40080a60:	b9403fe1 	ldr	w1, [sp, #60]
    40080a64:	11000422 	add	w2, w1, #0x1
    40080a68:	b9003fe2 	str	w2, [sp, #60]
    40080a6c:	93407c21 	sxtw	x1, w1
    40080a70:	f9400be2 	ldr	x2, [sp, #16]
    40080a74:	8b010041 	add	x1, x2, x1
    40080a78:	39000020 	strb	w0, [x1]
    } while (num /= base);
    40080a7c:	b9800fe0 	ldrsw	x0, [sp, #12]
    40080a80:	f9400fe1 	ldr	x1, [sp, #24]
    40080a84:	9ac00c20 	sdiv	x0, x1, x0
    40080a88:	f9000fe0 	str	x0, [sp, #24]
    40080a8c:	f9400fe0 	ldr	x0, [sp, #24]
    40080a90:	f100001f 	cmp	x0, #0x0
    40080a94:	54fffc21 	b.ne	40080a18 <int_to_str+0x7c>  // b.any

    if (is_negative)
    40080a98:	b94033e0 	ldr	w0, [sp, #48]
    40080a9c:	7100001f 	cmp	w0, #0x0
    40080aa0:	54000120 	b.eq	40080ac4 <int_to_str+0x128>  // b.none
    {
        str[i++] = '-';
    40080aa4:	b9403fe0 	ldr	w0, [sp, #60]
    40080aa8:	11000401 	add	w1, w0, #0x1
    40080aac:	b9003fe1 	str	w1, [sp, #60]
    40080ab0:	93407c00 	sxtw	x0, w0
    40080ab4:	f9400be1 	ldr	x1, [sp, #16]
    40080ab8:	8b000020 	add	x0, x1, x0
    40080abc:	528005a1 	mov	w1, #0x2d                  	// #45
    40080ac0:	39000001 	strb	w1, [x0]
    }

    str[i] = '\0';
    40080ac4:	b9803fe0 	ldrsw	x0, [sp, #60]
    40080ac8:	f9400be1 	ldr	x1, [sp, #16]
    40080acc:	8b000020 	add	x0, x1, x0
    40080ad0:	3900001f 	strb	wzr, [x0]

    // 反转字符串
    for (int start = 0, end = i - 1; start < end; start++, end--)
    40080ad4:	b9003bff 	str	wzr, [sp, #56]
    40080ad8:	b9403fe0 	ldr	w0, [sp, #60]
    40080adc:	51000400 	sub	w0, w0, #0x1
    40080ae0:	b90037e0 	str	w0, [sp, #52]
    40080ae4:	14000019 	b	40080b48 <int_to_str+0x1ac>
    {
        char temp = str[start];
    40080ae8:	b9803be0 	ldrsw	x0, [sp, #56]
    40080aec:	f9400be1 	ldr	x1, [sp, #16]
    40080af0:	8b000020 	add	x0, x1, x0
    40080af4:	39400000 	ldrb	w0, [x0]
    40080af8:	3900afe0 	strb	w0, [sp, #43]
        str[start] = str[end];
    40080afc:	b98037e0 	ldrsw	x0, [sp, #52]
    40080b00:	f9400be1 	ldr	x1, [sp, #16]
    40080b04:	8b000021 	add	x1, x1, x0
    40080b08:	b9803be0 	ldrsw	x0, [sp, #56]
    40080b0c:	f9400be2 	ldr	x2, [sp, #16]
    40080b10:	8b000040 	add	x0, x2, x0
    40080b14:	39400021 	ldrb	w1, [x1]
    40080b18:	39000001 	strb	w1, [x0]
        str[end] = temp;
    40080b1c:	b98037e0 	ldrsw	x0, [sp, #52]
    40080b20:	f9400be1 	ldr	x1, [sp, #16]
    40080b24:	8b000020 	add	x0, x1, x0
    40080b28:	3940afe1 	ldrb	w1, [sp, #43]
    40080b2c:	39000001 	strb	w1, [x0]
    for (int start = 0, end = i - 1; start < end; start++, end--)
    40080b30:	b9403be0 	ldr	w0, [sp, #56]
    40080b34:	11000400 	add	w0, w0, #0x1
    40080b38:	b9003be0 	str	w0, [sp, #56]
    40080b3c:	b94037e0 	ldr	w0, [sp, #52]
    40080b40:	51000400 	sub	w0, w0, #0x1
    40080b44:	b90037e0 	str	w0, [sp, #52]
    40080b48:	b9403be1 	ldr	w1, [sp, #56]
    40080b4c:	b94037e0 	ldr	w0, [sp, #52]
    40080b50:	6b00003f 	cmp	w1, w0
    40080b54:	54fffcab 	b.lt	40080ae8 <int_to_str+0x14c>  // b.tstop
    }
    return i;
    40080b58:	b9403fe0 	ldr	w0, [sp, #60]
}
    40080b5c:	910103ff 	add	sp, sp, #0x40
    40080b60:	d65f03c0 	ret

0000000040080b64 <tiny_vsnprintf>:

int tiny_vsnprintf(char *str, size_t size, const char *format, va_list ap)
{
    40080b64:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    40080b68:	910003fd 	mov	x29, sp
    40080b6c:	f9000bf3 	str	x19, [sp, #16]
    40080b70:	f9001fe0 	str	x0, [sp, #56]
    40080b74:	f9001be1 	str	x1, [sp, #48]
    40080b78:	f90017e2 	str	x2, [sp, #40]
    40080b7c:	aa0303f3 	mov	x19, x3
    size_t i = 0;
    40080b80:	f9004fff 	str	xzr, [sp, #152]
    const char *p = format;
    40080b84:	f94017e0 	ldr	x0, [sp, #40]
    40080b88:	f9004be0 	str	x0, [sp, #144]

    while (*p && i < size - 1)
    40080b8c:	140000c0 	b	40080e8c <tiny_vsnprintf+0x328>
    {
        if (*p != '%')
    40080b90:	f9404be0 	ldr	x0, [sp, #144]
    40080b94:	39400000 	ldrb	w0, [x0]
    40080b98:	7100941f 	cmp	w0, #0x25
    40080b9c:	54000180 	b.eq	40080bcc <tiny_vsnprintf+0x68>  // b.none
        {
            str[i++] = *p++;
    40080ba0:	f9404be0 	ldr	x0, [sp, #144]
    40080ba4:	91000401 	add	x1, x0, #0x1
    40080ba8:	f9004be1 	str	x1, [sp, #144]
    40080bac:	f9404fe1 	ldr	x1, [sp, #152]
    40080bb0:	91000422 	add	x2, x1, #0x1
    40080bb4:	f9004fe2 	str	x2, [sp, #152]
    40080bb8:	f9401fe2 	ldr	x2, [sp, #56]
    40080bbc:	8b010041 	add	x1, x2, x1
    40080bc0:	39400000 	ldrb	w0, [x0]
    40080bc4:	39000020 	strb	w0, [x1]
            continue;
    40080bc8:	140000b1 	b	40080e8c <tiny_vsnprintf+0x328>
        }

        p++; // 跳过 '%'
    40080bcc:	f9404be0 	ldr	x0, [sp, #144]
    40080bd0:	91000400 	add	x0, x0, #0x1
    40080bd4:	f9004be0 	str	x0, [sp, #144]
        switch (*p)
    40080bd8:	f9404be0 	ldr	x0, [sp, #144]
    40080bdc:	39400000 	ldrb	w0, [x0]
    40080be0:	7101e01f 	cmp	w0, #0x78
    40080be4:	54000760 	b.eq	40080cd0 <tiny_vsnprintf+0x16c>  // b.none
    40080be8:	7101e01f 	cmp	w0, #0x78
    40080bec:	540012ec 	b.gt	40080e48 <tiny_vsnprintf+0x2e4>
    40080bf0:	7101901f 	cmp	w0, #0x64
    40080bf4:	54000080 	b.eq	40080c04 <tiny_vsnprintf+0xa0>  // b.none
    40080bf8:	7101cc1f 	cmp	w0, #0x73
    40080bfc:	54000d00 	b.eq	40080d9c <tiny_vsnprintf+0x238>  // b.none
    40080c00:	14000092 	b	40080e48 <tiny_vsnprintf+0x2e4>
        {
        case 'd':
        {
            int val = va_arg(ap, long);
    40080c04:	b9401a61 	ldr	w1, [x19, #24]
    40080c08:	f9400260 	ldr	x0, [x19]
    40080c0c:	7100003f 	cmp	w1, #0x0
    40080c10:	540000ab 	b.lt	40080c24 <tiny_vsnprintf+0xc0>  // b.tstop
    40080c14:	91003c01 	add	x1, x0, #0xf
    40080c18:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080c1c:	f9000261 	str	x1, [x19]
    40080c20:	1400000d 	b	40080c54 <tiny_vsnprintf+0xf0>
    40080c24:	11002022 	add	w2, w1, #0x8
    40080c28:	b9001a62 	str	w2, [x19, #24]
    40080c2c:	b9401a62 	ldr	w2, [x19, #24]
    40080c30:	7100005f 	cmp	w2, #0x0
    40080c34:	540000ad 	b.le	40080c48 <tiny_vsnprintf+0xe4>
    40080c38:	91003c01 	add	x1, x0, #0xf
    40080c3c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080c40:	f9000261 	str	x1, [x19]
    40080c44:	14000004 	b	40080c54 <tiny_vsnprintf+0xf0>
    40080c48:	f9400662 	ldr	x2, [x19, #8]
    40080c4c:	93407c20 	sxtw	x0, w1
    40080c50:	8b000040 	add	x0, x2, x0
    40080c54:	f9400000 	ldr	x0, [x0]
    40080c58:	b90077e0 	str	w0, [sp, #116]
            char buf[20];
            int len = int_to_str(val, buf, 10);
    40080c5c:	b98077e0 	ldrsw	x0, [sp, #116]
    40080c60:	910163e1 	add	x1, sp, #0x58
    40080c64:	52800142 	mov	w2, #0xa                   	// #10
    40080c68:	97ffff4d 	bl	4008099c <int_to_str>
    40080c6c:	b90073e0 	str	w0, [sp, #112]
            for (int j = 0; j < len && i < size - 1; j++)
    40080c70:	b9008fff 	str	wzr, [sp, #140]
    40080c74:	1400000d 	b	40080ca8 <tiny_vsnprintf+0x144>
            {
                str[i++] = buf[j];
    40080c78:	f9404fe0 	ldr	x0, [sp, #152]
    40080c7c:	91000401 	add	x1, x0, #0x1
    40080c80:	f9004fe1 	str	x1, [sp, #152]
    40080c84:	f9401fe1 	ldr	x1, [sp, #56]
    40080c88:	8b000020 	add	x0, x1, x0
    40080c8c:	b9808fe1 	ldrsw	x1, [sp, #140]
    40080c90:	910163e2 	add	x2, sp, #0x58
    40080c94:	38616841 	ldrb	w1, [x2, x1]
    40080c98:	39000001 	strb	w1, [x0]
            for (int j = 0; j < len && i < size - 1; j++)
    40080c9c:	b9408fe0 	ldr	w0, [sp, #140]
    40080ca0:	11000400 	add	w0, w0, #0x1
    40080ca4:	b9008fe0 	str	w0, [sp, #140]
    40080ca8:	b9408fe1 	ldr	w1, [sp, #140]
    40080cac:	b94073e0 	ldr	w0, [sp, #112]
    40080cb0:	6b00003f 	cmp	w1, w0
    40080cb4:	54000dca 	b.ge	40080e6c <tiny_vsnprintf+0x308>  // b.tcont
    40080cb8:	f9401be0 	ldr	x0, [sp, #48]
    40080cbc:	d1000400 	sub	x0, x0, #0x1
    40080cc0:	f9404fe1 	ldr	x1, [sp, #152]
    40080cc4:	eb00003f 	cmp	x1, x0
    40080cc8:	54fffd83 	b.cc	40080c78 <tiny_vsnprintf+0x114>  // b.lo, b.ul, b.last
            }
            break;
    40080ccc:	14000068 	b	40080e6c <tiny_vsnprintf+0x308>
        }
        case 'x':
        {
            int val = va_arg(ap, int);
    40080cd0:	b9401a61 	ldr	w1, [x19, #24]
    40080cd4:	f9400260 	ldr	x0, [x19]
    40080cd8:	7100003f 	cmp	w1, #0x0
    40080cdc:	540000ab 	b.lt	40080cf0 <tiny_vsnprintf+0x18c>  // b.tstop
    40080ce0:	91002c01 	add	x1, x0, #0xb
    40080ce4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080ce8:	f9000261 	str	x1, [x19]
    40080cec:	1400000d 	b	40080d20 <tiny_vsnprintf+0x1bc>
    40080cf0:	11002022 	add	w2, w1, #0x8
    40080cf4:	b9001a62 	str	w2, [x19, #24]
    40080cf8:	b9401a62 	ldr	w2, [x19, #24]
    40080cfc:	7100005f 	cmp	w2, #0x0
    40080d00:	540000ad 	b.le	40080d14 <tiny_vsnprintf+0x1b0>
    40080d04:	91002c01 	add	x1, x0, #0xb
    40080d08:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080d0c:	f9000261 	str	x1, [x19]
    40080d10:	14000004 	b	40080d20 <tiny_vsnprintf+0x1bc>
    40080d14:	f9400662 	ldr	x2, [x19, #8]
    40080d18:	93407c20 	sxtw	x0, w1
    40080d1c:	8b000040 	add	x0, x2, x0
    40080d20:	b9400000 	ldr	w0, [x0]
    40080d24:	b9007fe0 	str	w0, [sp, #124]
            char buf[20];
            int len = int_to_str(val, buf, 16);
    40080d28:	b9807fe0 	ldrsw	x0, [sp, #124]
    40080d2c:	910103e1 	add	x1, sp, #0x40
    40080d30:	52800202 	mov	w2, #0x10                  	// #16
    40080d34:	97ffff1a 	bl	4008099c <int_to_str>
    40080d38:	b9007be0 	str	w0, [sp, #120]
            for (int j = 0; j < len && i < size - 1; j++)
    40080d3c:	b9008bff 	str	wzr, [sp, #136]
    40080d40:	1400000d 	b	40080d74 <tiny_vsnprintf+0x210>
            {
                str[i++] = buf[j];
    40080d44:	f9404fe0 	ldr	x0, [sp, #152]
    40080d48:	91000401 	add	x1, x0, #0x1
    40080d4c:	f9004fe1 	str	x1, [sp, #152]
    40080d50:	f9401fe1 	ldr	x1, [sp, #56]
    40080d54:	8b000020 	add	x0, x1, x0
    40080d58:	b9808be1 	ldrsw	x1, [sp, #136]
    40080d5c:	910103e2 	add	x2, sp, #0x40
    40080d60:	38616841 	ldrb	w1, [x2, x1]
    40080d64:	39000001 	strb	w1, [x0]
            for (int j = 0; j < len && i < size - 1; j++)
    40080d68:	b9408be0 	ldr	w0, [sp, #136]
    40080d6c:	11000400 	add	w0, w0, #0x1
    40080d70:	b9008be0 	str	w0, [sp, #136]
    40080d74:	b9408be1 	ldr	w1, [sp, #136]
    40080d78:	b9407be0 	ldr	w0, [sp, #120]
    40080d7c:	6b00003f 	cmp	w1, w0
    40080d80:	540007aa 	b.ge	40080e74 <tiny_vsnprintf+0x310>  // b.tcont
    40080d84:	f9401be0 	ldr	x0, [sp, #48]
    40080d88:	d1000400 	sub	x0, x0, #0x1
    40080d8c:	f9404fe1 	ldr	x1, [sp, #152]
    40080d90:	eb00003f 	cmp	x1, x0
    40080d94:	54fffd83 	b.cc	40080d44 <tiny_vsnprintf+0x1e0>  // b.lo, b.ul, b.last
            }
            break;
    40080d98:	14000037 	b	40080e74 <tiny_vsnprintf+0x310>
        }
        case 's':
        {
            char *val = va_arg(ap, char *);
    40080d9c:	b9401a61 	ldr	w1, [x19, #24]
    40080da0:	f9400260 	ldr	x0, [x19]
    40080da4:	7100003f 	cmp	w1, #0x0
    40080da8:	540000ab 	b.lt	40080dbc <tiny_vsnprintf+0x258>  // b.tstop
    40080dac:	91003c01 	add	x1, x0, #0xf
    40080db0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080db4:	f9000261 	str	x1, [x19]
    40080db8:	1400000d 	b	40080dec <tiny_vsnprintf+0x288>
    40080dbc:	11002022 	add	w2, w1, #0x8
    40080dc0:	b9001a62 	str	w2, [x19, #24]
    40080dc4:	b9401a62 	ldr	w2, [x19, #24]
    40080dc8:	7100005f 	cmp	w2, #0x0
    40080dcc:	540000ad 	b.le	40080de0 <tiny_vsnprintf+0x27c>
    40080dd0:	91003c01 	add	x1, x0, #0xf
    40080dd4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40080dd8:	f9000261 	str	x1, [x19]
    40080ddc:	14000004 	b	40080dec <tiny_vsnprintf+0x288>
    40080de0:	f9400662 	ldr	x2, [x19, #8]
    40080de4:	93407c20 	sxtw	x0, w1
    40080de8:	8b000040 	add	x0, x2, x0
    40080dec:	f9400000 	ldr	x0, [x0]
    40080df0:	f90043e0 	str	x0, [sp, #128]
            while (*val && i < size - 1)
    40080df4:	1400000b 	b	40080e20 <tiny_vsnprintf+0x2bc>
            {
                str[i++] = *val++;
    40080df8:	f94043e0 	ldr	x0, [sp, #128]
    40080dfc:	91000401 	add	x1, x0, #0x1
    40080e00:	f90043e1 	str	x1, [sp, #128]
    40080e04:	f9404fe1 	ldr	x1, [sp, #152]
    40080e08:	91000422 	add	x2, x1, #0x1
    40080e0c:	f9004fe2 	str	x2, [sp, #152]
    40080e10:	f9401fe2 	ldr	x2, [sp, #56]
    40080e14:	8b010041 	add	x1, x2, x1
    40080e18:	39400000 	ldrb	w0, [x0]
    40080e1c:	39000020 	strb	w0, [x1]
            while (*val && i < size - 1)
    40080e20:	f94043e0 	ldr	x0, [sp, #128]
    40080e24:	39400000 	ldrb	w0, [x0]
    40080e28:	7100001f 	cmp	w0, #0x0
    40080e2c:	54000280 	b.eq	40080e7c <tiny_vsnprintf+0x318>  // b.none
    40080e30:	f9401be0 	ldr	x0, [sp, #48]
    40080e34:	d1000400 	sub	x0, x0, #0x1
    40080e38:	f9404fe1 	ldr	x1, [sp, #152]
    40080e3c:	eb00003f 	cmp	x1, x0
    40080e40:	54fffdc3 	b.cc	40080df8 <tiny_vsnprintf+0x294>  // b.lo, b.ul, b.last
            }
            break;
    40080e44:	1400000e 	b	40080e7c <tiny_vsnprintf+0x318>
        }
        default:
            str[i++] = *p;
    40080e48:	f9404fe0 	ldr	x0, [sp, #152]
    40080e4c:	91000401 	add	x1, x0, #0x1
    40080e50:	f9004fe1 	str	x1, [sp, #152]
    40080e54:	f9401fe1 	ldr	x1, [sp, #56]
    40080e58:	8b000020 	add	x0, x1, x0
    40080e5c:	f9404be1 	ldr	x1, [sp, #144]
    40080e60:	39400021 	ldrb	w1, [x1]
    40080e64:	39000001 	strb	w1, [x0]
            break;
    40080e68:	14000006 	b	40080e80 <tiny_vsnprintf+0x31c>
            break;
    40080e6c:	d503201f 	nop
    40080e70:	14000004 	b	40080e80 <tiny_vsnprintf+0x31c>
            break;
    40080e74:	d503201f 	nop
    40080e78:	14000002 	b	40080e80 <tiny_vsnprintf+0x31c>
            break;
    40080e7c:	d503201f 	nop
        }
        p++;
    40080e80:	f9404be0 	ldr	x0, [sp, #144]
    40080e84:	91000400 	add	x0, x0, #0x1
    40080e88:	f9004be0 	str	x0, [sp, #144]
    while (*p && i < size - 1)
    40080e8c:	f9404be0 	ldr	x0, [sp, #144]
    40080e90:	39400000 	ldrb	w0, [x0]
    40080e94:	7100001f 	cmp	w0, #0x0
    40080e98:	540000c0 	b.eq	40080eb0 <tiny_vsnprintf+0x34c>  // b.none
    40080e9c:	f9401be0 	ldr	x0, [sp, #48]
    40080ea0:	d1000400 	sub	x0, x0, #0x1
    40080ea4:	f9404fe1 	ldr	x1, [sp, #152]
    40080ea8:	eb00003f 	cmp	x1, x0
    40080eac:	54ffe723 	b.cc	40080b90 <tiny_vsnprintf+0x2c>  // b.lo, b.ul, b.last
    }

    str[i] = '\0';
    40080eb0:	f9401fe1 	ldr	x1, [sp, #56]
    40080eb4:	f9404fe0 	ldr	x0, [sp, #152]
    40080eb8:	8b000020 	add	x0, x1, x0
    40080ebc:	3900001f 	strb	wzr, [x0]
    return i;
    40080ec0:	f9404fe0 	ldr	x0, [sp, #152]
}
    40080ec4:	f9400bf3 	ldr	x19, [sp, #16]
    40080ec8:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    40080ecc:	d65f03c0 	ret

0000000040080ed0 <tiny_printf>:

void tiny_printf(const char *format, ...)
{
    40080ed0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    40080ed4:	910003fd 	mov	x29, sp
    40080ed8:	a90153f3 	stp	x19, x20, [sp, #16]
    40080edc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40080ee0:	a90363f7 	stp	x23, x24, [sp, #48]
    40080ee4:	a9046bf9 	stp	x25, x26, [sp, #64]
    40080ee8:	f9002bfb 	str	x27, [sp, #80]
    40080eec:	f90047a0 	str	x0, [x29, #136]
    40080ef0:	f9006fa1 	str	x1, [x29, #216]
    40080ef4:	f90073a2 	str	x2, [x29, #224]
    40080ef8:	f90077a3 	str	x3, [x29, #232]
    40080efc:	f9007ba4 	str	x4, [x29, #240]
    40080f00:	f9007fa5 	str	x5, [x29, #248]
    40080f04:	f90083a6 	str	x6, [x29, #256]
    40080f08:	f90087a7 	str	x7, [x29, #264]
    40080f0c:	910003e0 	mov	x0, sp
    40080f10:	aa0003f3 	mov	x19, x0
    va_list args;
    va_start(args, format);
    40080f14:	910443a0 	add	x0, x29, #0x110
    40080f18:	f9004fa0 	str	x0, [x29, #152]
    40080f1c:	910443a0 	add	x0, x29, #0x110
    40080f20:	f90053a0 	str	x0, [x29, #160]
    40080f24:	910343a0 	add	x0, x29, #0xd0
    40080f28:	f90057a0 	str	x0, [x29, #168]
    40080f2c:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    40080f30:	b900b3a0 	str	w0, [x29, #176]
    40080f34:	b900b7bf 	str	wzr, [x29, #180]
    uint16_t len = tiny_vsnprintf(NULL, 0, format, args);
    40080f38:	910183a2 	add	x2, x29, #0x60
    40080f3c:	910263a3 	add	x3, x29, #0x98
    40080f40:	a9400460 	ldp	x0, x1, [x3]
    40080f44:	a9000440 	stp	x0, x1, [x2]
    40080f48:	a9410460 	ldp	x0, x1, [x3, #16]
    40080f4c:	a9010440 	stp	x0, x1, [x2, #16]
    40080f50:	910183a0 	add	x0, x29, #0x60
    40080f54:	aa0003e3 	mov	x3, x0
    40080f58:	f94047a2 	ldr	x2, [x29, #136]
    40080f5c:	d2800001 	mov	x1, #0x0                   	// #0
    40080f60:	d2800000 	mov	x0, #0x0                   	// #0
    40080f64:	97ffff00 	bl	40080b64 <tiny_vsnprintf>
    40080f68:	79019fa0 	strh	w0, [x29, #206]
    va_end(args);

    char buffer[len + 1];
    40080f6c:	79419fa0 	ldrh	w0, [x29, #206]
    40080f70:	11000400 	add	w0, w0, #0x1
    40080f74:	93407c01 	sxtw	x1, w0
    40080f78:	d1000421 	sub	x1, x1, #0x1
    40080f7c:	f90063a1 	str	x1, [x29, #192]
    40080f80:	93407c01 	sxtw	x1, w0
    40080f84:	aa0103fa 	mov	x26, x1
    40080f88:	d280001b 	mov	x27, #0x0                   	// #0
    40080f8c:	d37dff41 	lsr	x1, x26, #61
    40080f90:	d37df377 	lsl	x23, x27, #3
    40080f94:	aa170037 	orr	x23, x1, x23
    40080f98:	d37df356 	lsl	x22, x26, #3
    40080f9c:	93407c01 	sxtw	x1, w0
    40080fa0:	aa0103f8 	mov	x24, x1
    40080fa4:	d2800019 	mov	x25, #0x0                   	// #0
    40080fa8:	d37dff01 	lsr	x1, x24, #61
    40080fac:	d37df335 	lsl	x21, x25, #3
    40080fb0:	aa150035 	orr	x21, x1, x21
    40080fb4:	d37df314 	lsl	x20, x24, #3
    40080fb8:	93407c00 	sxtw	x0, w0
    40080fbc:	91003c00 	add	x0, x0, #0xf
    40080fc0:	d344fc00 	lsr	x0, x0, #4
    40080fc4:	d37cec00 	lsl	x0, x0, #4
    40080fc8:	cb2063ff 	sub	sp, sp, x0
    40080fcc:	910003e0 	mov	x0, sp
    40080fd0:	91000000 	add	x0, x0, #0x0
    40080fd4:	f9005fa0 	str	x0, [x29, #184]

    va_start(args, format);
    40080fd8:	910443a0 	add	x0, x29, #0x110
    40080fdc:	f9004fa0 	str	x0, [x29, #152]
    40080fe0:	910443a0 	add	x0, x29, #0x110
    40080fe4:	f90053a0 	str	x0, [x29, #160]
    40080fe8:	910343a0 	add	x0, x29, #0xd0
    40080fec:	f90057a0 	str	x0, [x29, #168]
    40080ff0:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    40080ff4:	b900b3a0 	str	w0, [x29, #176]
    40080ff8:	b900b7bf 	str	wzr, [x29, #180]
    tiny_vsnprintf(buffer, len + 1, format, args);
    40080ffc:	79419fa0 	ldrh	w0, [x29, #206]
    40081000:	11000400 	add	w0, w0, #0x1
    40081004:	93407c04 	sxtw	x4, w0
    40081008:	910183a2 	add	x2, x29, #0x60
    4008100c:	910263a3 	add	x3, x29, #0x98
    40081010:	a9400460 	ldp	x0, x1, [x3]
    40081014:	a9000440 	stp	x0, x1, [x2]
    40081018:	a9410460 	ldp	x0, x1, [x3, #16]
    4008101c:	a9010440 	stp	x0, x1, [x2, #16]
    40081020:	910183a0 	add	x0, x29, #0x60
    40081024:	aa0003e3 	mov	x3, x0
    40081028:	f94047a2 	ldr	x2, [x29, #136]
    4008102c:	aa0403e1 	mov	x1, x4
    40081030:	f9405fa0 	ldr	x0, [x29, #184]
    40081034:	97fffecc 	bl	40080b64 <tiny_vsnprintf>
    va_end(args);

    uart_putstr(buffer);
    40081038:	f9405fa0 	ldr	x0, [x29, #184]
    4008103c:	97fffe29 	bl	400808e0 <uart_putstr>
    40081040:	9100027f 	mov	sp, x19
}
    40081044:	d503201f 	nop
    40081048:	910003bf 	mov	sp, x29
    4008104c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40081050:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40081054:	a94363f7 	ldp	x23, x24, [sp, #48]
    40081058:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4008105c:	f9402bfb 	ldr	x27, [sp, #80]
    40081060:	a8d17bfd 	ldp	x29, x30, [sp], #272
    40081064:	d65f03c0 	ret

0000000040081068 <tiny_hello>:

void tiny_hello(void)
{
    40081068:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4008106c:	910003fd 	mov	x29, sp
    tiny_printf("Hello, ARM Tiny!\n");
    40081070:	b0000000 	adrp	x0, 40082000 <exception_vector_base+0x800>
    40081074:	910b2000 	add	x0, x0, #0x2c8
    40081078:	97ffff96 	bl	40080ed0 <tiny_printf>
}
    4008107c:	d503201f 	nop
    40081080:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40081084:	d65f03c0 	ret
	...

0000000040081800 <exception_vector_base>:
.extern handle_sync_exception
.extern handle_irq_exception

exception_vector_base:
    // current EL, with SP_EL0
    INVALID_EXCP 0 0
    40081800:	d10443ff 	sub	sp, sp, #0x110
    40081804:	a90007e0 	stp	x0, x1, [sp]
    40081808:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008180c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081810:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081814:	a90427e8 	stp	x8, x9, [sp, #64]
    40081818:	a9052fea 	stp	x10, x11, [sp, #80]
    4008181c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081820:	a9073fee 	stp	x14, x15, [sp, #112]
    40081824:	a90847f0 	stp	x16, x17, [sp, #128]
    40081828:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008182c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081830:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081834:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081838:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008183c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081840:	d5384109 	mrs	x9, sp_el0
    40081844:	d538402a 	mrs	x10, elr_el1
    40081848:	d538400b 	mrs	x11, spsr_el1
    4008184c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081850:	a9102fea 	stp	x10, x11, [sp, #256]
    40081854:	910003e0 	mov	x0, sp
    40081858:	d2800001 	mov	x1, #0x0                   	// #0
    4008185c:	d2800002 	mov	x2, #0x0                   	// #0
    40081860:	97fffb8d 	bl	40080694 <invalid_exception>
    40081864:	140001e1 	b	40081fe8 <exception_vector_base+0x7e8>
    40081868:	d503201f 	nop
    4008186c:	d503201f 	nop
    40081870:	d503201f 	nop
    40081874:	d503201f 	nop
    40081878:	d503201f 	nop
    4008187c:	d503201f 	nop
    INVALID_EXCP 1 0
    40081880:	d10443ff 	sub	sp, sp, #0x110
    40081884:	a90007e0 	stp	x0, x1, [sp]
    40081888:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008188c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081890:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081894:	a90427e8 	stp	x8, x9, [sp, #64]
    40081898:	a9052fea 	stp	x10, x11, [sp, #80]
    4008189c:	a90637ec 	stp	x12, x13, [sp, #96]
    400818a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400818a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400818a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400818ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400818b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400818b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400818b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400818bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400818c0:	d5384109 	mrs	x9, sp_el0
    400818c4:	d538402a 	mrs	x10, elr_el1
    400818c8:	d538400b 	mrs	x11, spsr_el1
    400818cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400818d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400818d4:	910003e0 	mov	x0, sp
    400818d8:	d2800021 	mov	x1, #0x1                   	// #1
    400818dc:	d2800002 	mov	x2, #0x0                   	// #0
    400818e0:	97fffb6d 	bl	40080694 <invalid_exception>
    400818e4:	140001c1 	b	40081fe8 <exception_vector_base+0x7e8>
    400818e8:	d503201f 	nop
    400818ec:	d503201f 	nop
    400818f0:	d503201f 	nop
    400818f4:	d503201f 	nop
    400818f8:	d503201f 	nop
    400818fc:	d503201f 	nop
    INVALID_EXCP 2 0
    40081900:	d10443ff 	sub	sp, sp, #0x110
    40081904:	a90007e0 	stp	x0, x1, [sp]
    40081908:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008190c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081910:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081914:	a90427e8 	stp	x8, x9, [sp, #64]
    40081918:	a9052fea 	stp	x10, x11, [sp, #80]
    4008191c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081920:	a9073fee 	stp	x14, x15, [sp, #112]
    40081924:	a90847f0 	stp	x16, x17, [sp, #128]
    40081928:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008192c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081930:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081934:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081938:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008193c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081940:	d5384109 	mrs	x9, sp_el0
    40081944:	d538402a 	mrs	x10, elr_el1
    40081948:	d538400b 	mrs	x11, spsr_el1
    4008194c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081950:	a9102fea 	stp	x10, x11, [sp, #256]
    40081954:	910003e0 	mov	x0, sp
    40081958:	d2800041 	mov	x1, #0x2                   	// #2
    4008195c:	d2800002 	mov	x2, #0x0                   	// #0
    40081960:	97fffb4d 	bl	40080694 <invalid_exception>
    40081964:	140001a1 	b	40081fe8 <exception_vector_base+0x7e8>
    40081968:	d503201f 	nop
    4008196c:	d503201f 	nop
    40081970:	d503201f 	nop
    40081974:	d503201f 	nop
    40081978:	d503201f 	nop
    4008197c:	d503201f 	nop
    INVALID_EXCP 3 0
    40081980:	d10443ff 	sub	sp, sp, #0x110
    40081984:	a90007e0 	stp	x0, x1, [sp]
    40081988:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008198c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081990:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081994:	a90427e8 	stp	x8, x9, [sp, #64]
    40081998:	a9052fea 	stp	x10, x11, [sp, #80]
    4008199c:	a90637ec 	stp	x12, x13, [sp, #96]
    400819a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400819a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400819a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400819ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400819b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400819b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400819b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400819bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400819c0:	d5384109 	mrs	x9, sp_el0
    400819c4:	d538402a 	mrs	x10, elr_el1
    400819c8:	d538400b 	mrs	x11, spsr_el1
    400819cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400819d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400819d4:	910003e0 	mov	x0, sp
    400819d8:	d2800061 	mov	x1, #0x3                   	// #3
    400819dc:	d2800002 	mov	x2, #0x0                   	// #0
    400819e0:	97fffb2d 	bl	40080694 <invalid_exception>
    400819e4:	14000181 	b	40081fe8 <exception_vector_base+0x7e8>
    400819e8:	d503201f 	nop
    400819ec:	d503201f 	nop
    400819f0:	d503201f 	nop
    400819f4:	d503201f 	nop
    400819f8:	d503201f 	nop
    400819fc:	d503201f 	nop

    // current EL, with SP_ELx
    HANDLE_SYNC
    40081a00:	d10443ff 	sub	sp, sp, #0x110
    40081a04:	a90007e0 	stp	x0, x1, [sp]
    40081a08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081a0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081a10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081a14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081a18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081a1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081a20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081a24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081a28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081a2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081a30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081a34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081a38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081a3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081a40:	d5384109 	mrs	x9, sp_el0
    40081a44:	d538402a 	mrs	x10, elr_el1
    40081a48:	d538400b 	mrs	x11, spsr_el1
    40081a4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081a50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081a54:	910003e0 	mov	x0, sp
    40081a58:	97fffac1 	bl	4008055c <handle_sync_exception>
    40081a5c:	14000163 	b	40081fe8 <exception_vector_base+0x7e8>
    40081a60:	d503201f 	nop
    40081a64:	d503201f 	nop
    40081a68:	d503201f 	nop
    40081a6c:	d503201f 	nop
    40081a70:	d503201f 	nop
    40081a74:	d503201f 	nop
    40081a78:	d503201f 	nop
    40081a7c:	d503201f 	nop
    HANDLE_IRQ
    40081a80:	d10443ff 	sub	sp, sp, #0x110
    40081a84:	a90007e0 	stp	x0, x1, [sp]
    40081a88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081a8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081a90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081a94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081a98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081a9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081aa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081aa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081aa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081aac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081ab0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081ab4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081ab8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081abc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081ac0:	d5384109 	mrs	x9, sp_el0
    40081ac4:	d538402a 	mrs	x10, elr_el1
    40081ac8:	d538400b 	mrs	x11, spsr_el1
    40081acc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081ad0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081ad4:	910003e0 	mov	x0, sp
    40081ad8:	97fffad8 	bl	40080638 <handle_irq_exception>
    40081adc:	14000143 	b	40081fe8 <exception_vector_base+0x7e8>
    40081ae0:	d503201f 	nop
    40081ae4:	d503201f 	nop
    40081ae8:	d503201f 	nop
    40081aec:	d503201f 	nop
    40081af0:	d503201f 	nop
    40081af4:	d503201f 	nop
    40081af8:	d503201f 	nop
    40081afc:	d503201f 	nop
    INVALID_EXCP 2 1
    40081b00:	d10443ff 	sub	sp, sp, #0x110
    40081b04:	a90007e0 	stp	x0, x1, [sp]
    40081b08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081b0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081b10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081b14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081b18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081b1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081b20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081b24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081b28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081b2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081b30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081b34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081b38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081b3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081b40:	d5384109 	mrs	x9, sp_el0
    40081b44:	d538402a 	mrs	x10, elr_el1
    40081b48:	d538400b 	mrs	x11, spsr_el1
    40081b4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081b50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081b54:	910003e0 	mov	x0, sp
    40081b58:	d2800041 	mov	x1, #0x2                   	// #2
    40081b5c:	d2800022 	mov	x2, #0x1                   	// #1
    40081b60:	97fffacd 	bl	40080694 <invalid_exception>
    40081b64:	14000121 	b	40081fe8 <exception_vector_base+0x7e8>
    40081b68:	d503201f 	nop
    40081b6c:	d503201f 	nop
    40081b70:	d503201f 	nop
    40081b74:	d503201f 	nop
    40081b78:	d503201f 	nop
    40081b7c:	d503201f 	nop
    INVALID_EXCP 3 1
    40081b80:	d10443ff 	sub	sp, sp, #0x110
    40081b84:	a90007e0 	stp	x0, x1, [sp]
    40081b88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081b8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081b90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081b94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081b98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081b9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ba0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ba4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ba8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081bac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081bb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081bb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081bb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081bbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081bc0:	d5384109 	mrs	x9, sp_el0
    40081bc4:	d538402a 	mrs	x10, elr_el1
    40081bc8:	d538400b 	mrs	x11, spsr_el1
    40081bcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081bd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081bd4:	910003e0 	mov	x0, sp
    40081bd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081bdc:	d2800022 	mov	x2, #0x1                   	// #1
    40081be0:	97fffaad 	bl	40080694 <invalid_exception>
    40081be4:	14000101 	b	40081fe8 <exception_vector_base+0x7e8>
    40081be8:	d503201f 	nop
    40081bec:	d503201f 	nop
    40081bf0:	d503201f 	nop
    40081bf4:	d503201f 	nop
    40081bf8:	d503201f 	nop
    40081bfc:	d503201f 	nop

    // lower EL, aarch64
    HANDLE_SYNC
    40081c00:	d10443ff 	sub	sp, sp, #0x110
    40081c04:	a90007e0 	stp	x0, x1, [sp]
    40081c08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081c0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081c10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081c14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081c18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081c1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081c20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081c24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081c28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081c2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081c30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081c34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081c38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081c3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081c40:	d5384109 	mrs	x9, sp_el0
    40081c44:	d538402a 	mrs	x10, elr_el1
    40081c48:	d538400b 	mrs	x11, spsr_el1
    40081c4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081c50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081c54:	910003e0 	mov	x0, sp
    40081c58:	97fffa41 	bl	4008055c <handle_sync_exception>
    40081c5c:	140000e3 	b	40081fe8 <exception_vector_base+0x7e8>
    40081c60:	d503201f 	nop
    40081c64:	d503201f 	nop
    40081c68:	d503201f 	nop
    40081c6c:	d503201f 	nop
    40081c70:	d503201f 	nop
    40081c74:	d503201f 	nop
    40081c78:	d503201f 	nop
    40081c7c:	d503201f 	nop
    HANDLE_IRQ
    40081c80:	d10443ff 	sub	sp, sp, #0x110
    40081c84:	a90007e0 	stp	x0, x1, [sp]
    40081c88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081c8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081c90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081c94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081c98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081c9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ca0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ca4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ca8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081cac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081cb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081cb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081cb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081cbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081cc0:	d5384109 	mrs	x9, sp_el0
    40081cc4:	d538402a 	mrs	x10, elr_el1
    40081cc8:	d538400b 	mrs	x11, spsr_el1
    40081ccc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081cd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081cd4:	910003e0 	mov	x0, sp
    40081cd8:	97fffa58 	bl	40080638 <handle_irq_exception>
    40081cdc:	140000c3 	b	40081fe8 <exception_vector_base+0x7e8>
    40081ce0:	d503201f 	nop
    40081ce4:	d503201f 	nop
    40081ce8:	d503201f 	nop
    40081cec:	d503201f 	nop
    40081cf0:	d503201f 	nop
    40081cf4:	d503201f 	nop
    40081cf8:	d503201f 	nop
    40081cfc:	d503201f 	nop
    INVALID_EXCP 2 2
    40081d00:	d10443ff 	sub	sp, sp, #0x110
    40081d04:	a90007e0 	stp	x0, x1, [sp]
    40081d08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081d0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081d10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081d14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081d18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081d1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081d20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081d24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081d28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081d2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081d30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081d34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081d38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081d3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081d40:	d5384109 	mrs	x9, sp_el0
    40081d44:	d538402a 	mrs	x10, elr_el1
    40081d48:	d538400b 	mrs	x11, spsr_el1
    40081d4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081d50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081d54:	910003e0 	mov	x0, sp
    40081d58:	d2800041 	mov	x1, #0x2                   	// #2
    40081d5c:	d2800042 	mov	x2, #0x2                   	// #2
    40081d60:	97fffa4d 	bl	40080694 <invalid_exception>
    40081d64:	140000a1 	b	40081fe8 <exception_vector_base+0x7e8>
    40081d68:	d503201f 	nop
    40081d6c:	d503201f 	nop
    40081d70:	d503201f 	nop
    40081d74:	d503201f 	nop
    40081d78:	d503201f 	nop
    40081d7c:	d503201f 	nop
    INVALID_EXCP 3 2
    40081d80:	d10443ff 	sub	sp, sp, #0x110
    40081d84:	a90007e0 	stp	x0, x1, [sp]
    40081d88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081d8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081d90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081d94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081d98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081d9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081da0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081da4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081da8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081dac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081db0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081db4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081db8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081dbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081dc0:	d5384109 	mrs	x9, sp_el0
    40081dc4:	d538402a 	mrs	x10, elr_el1
    40081dc8:	d538400b 	mrs	x11, spsr_el1
    40081dcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081dd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081dd4:	910003e0 	mov	x0, sp
    40081dd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081ddc:	d2800042 	mov	x2, #0x2                   	// #2
    40081de0:	97fffa2d 	bl	40080694 <invalid_exception>
    40081de4:	14000081 	b	40081fe8 <exception_vector_base+0x7e8>
    40081de8:	d503201f 	nop
    40081dec:	d503201f 	nop
    40081df0:	d503201f 	nop
    40081df4:	d503201f 	nop
    40081df8:	d503201f 	nop
    40081dfc:	d503201f 	nop

    // lower EL, aarch32
    INVALID_EXCP 0 3
    40081e00:	d10443ff 	sub	sp, sp, #0x110
    40081e04:	a90007e0 	stp	x0, x1, [sp]
    40081e08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081e0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081e10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081e14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081e18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081e1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081e20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081e24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081e28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081e2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081e30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081e34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081e38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081e3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081e40:	d5384109 	mrs	x9, sp_el0
    40081e44:	d538402a 	mrs	x10, elr_el1
    40081e48:	d538400b 	mrs	x11, spsr_el1
    40081e4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081e50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081e54:	910003e0 	mov	x0, sp
    40081e58:	d2800001 	mov	x1, #0x0                   	// #0
    40081e5c:	d2800062 	mov	x2, #0x3                   	// #3
    40081e60:	97fffa0d 	bl	40080694 <invalid_exception>
    40081e64:	14000061 	b	40081fe8 <exception_vector_base+0x7e8>
    40081e68:	d503201f 	nop
    40081e6c:	d503201f 	nop
    40081e70:	d503201f 	nop
    40081e74:	d503201f 	nop
    40081e78:	d503201f 	nop
    40081e7c:	d503201f 	nop
    INVALID_EXCP 1 3
    40081e80:	d10443ff 	sub	sp, sp, #0x110
    40081e84:	a90007e0 	stp	x0, x1, [sp]
    40081e88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081e8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081e90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081e94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081e98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081e9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ea0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ea4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ea8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081eac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081eb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081eb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081eb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081ebc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081ec0:	d5384109 	mrs	x9, sp_el0
    40081ec4:	d538402a 	mrs	x10, elr_el1
    40081ec8:	d538400b 	mrs	x11, spsr_el1
    40081ecc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081ed0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081ed4:	910003e0 	mov	x0, sp
    40081ed8:	d2800021 	mov	x1, #0x1                   	// #1
    40081edc:	d2800062 	mov	x2, #0x3                   	// #3
    40081ee0:	97fff9ed 	bl	40080694 <invalid_exception>
    40081ee4:	14000041 	b	40081fe8 <exception_vector_base+0x7e8>
    40081ee8:	d503201f 	nop
    40081eec:	d503201f 	nop
    40081ef0:	d503201f 	nop
    40081ef4:	d503201f 	nop
    40081ef8:	d503201f 	nop
    40081efc:	d503201f 	nop
    INVALID_EXCP 2 3
    40081f00:	d10443ff 	sub	sp, sp, #0x110
    40081f04:	a90007e0 	stp	x0, x1, [sp]
    40081f08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081f0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081f10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081f14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081f18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081f1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081f20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081f24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081f28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081f2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081f30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081f34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081f38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081f3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081f40:	d5384109 	mrs	x9, sp_el0
    40081f44:	d538402a 	mrs	x10, elr_el1
    40081f48:	d538400b 	mrs	x11, spsr_el1
    40081f4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081f50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081f54:	910003e0 	mov	x0, sp
    40081f58:	d2800041 	mov	x1, #0x2                   	// #2
    40081f5c:	d2800062 	mov	x2, #0x3                   	// #3
    40081f60:	97fff9cd 	bl	40080694 <invalid_exception>
    40081f64:	14000021 	b	40081fe8 <exception_vector_base+0x7e8>
    40081f68:	d503201f 	nop
    40081f6c:	d503201f 	nop
    40081f70:	d503201f 	nop
    40081f74:	d503201f 	nop
    40081f78:	d503201f 	nop
    40081f7c:	d503201f 	nop
    INVALID_EXCP 3 3
    40081f80:	d10443ff 	sub	sp, sp, #0x110
    40081f84:	a90007e0 	stp	x0, x1, [sp]
    40081f88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081f8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081f90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081f94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081f98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081f9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081fa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081fa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081fa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081fac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081fb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081fb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081fb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081fbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081fc0:	d5384109 	mrs	x9, sp_el0
    40081fc4:	d538402a 	mrs	x10, elr_el1
    40081fc8:	d538400b 	mrs	x11, spsr_el1
    40081fcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081fd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081fd4:	910003e0 	mov	x0, sp
    40081fd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081fdc:	d2800062 	mov	x2, #0x3                   	// #3
    40081fe0:	97fff9ad 	bl	40080694 <invalid_exception>
    40081fe4:	14000001 	b	40081fe8 <exception_vector_base+0x7e8>

.Lexception_return:
    RESTORE_REGS
    40081fe8:	a9502fea 	ldp	x10, x11, [sp, #256]
    40081fec:	a94f27fe 	ldp	x30, x9, [sp, #240]
    40081ff0:	d5184109 	msr	sp_el0, x9
    40081ff4:	d518402a 	msr	elr_el1, x10
    40081ff8:	d518400b 	msr	spsr_el1, x11
    40081ffc:	a94e77fc 	ldp	x28, x29, [sp, #224]
    40082000:	a94d6ffa 	ldp	x26, x27, [sp, #208]
    40082004:	a94c67f8 	ldp	x24, x25, [sp, #192]
    40082008:	a94b5ff6 	ldp	x22, x23, [sp, #176]
    4008200c:	a94a57f4 	ldp	x20, x21, [sp, #160]
    40082010:	a9494ff2 	ldp	x18, x19, [sp, #144]
    40082014:	a94847f0 	ldp	x16, x17, [sp, #128]
    40082018:	a9473fee 	ldp	x14, x15, [sp, #112]
    4008201c:	a94637ec 	ldp	x12, x13, [sp, #96]
    40082020:	a9452fea 	ldp	x10, x11, [sp, #80]
    40082024:	a94427e8 	ldp	x8, x9, [sp, #64]
    40082028:	a9431fe6 	ldp	x6, x7, [sp, #48]
    4008202c:	a94217e4 	ldp	x4, x5, [sp, #32]
    40082030:	a9410fe2 	ldp	x2, x3, [sp, #16]
    40082034:	a94007e0 	ldp	x0, x1, [sp]
    40082038:	910443ff 	add	sp, sp, #0x110
    eret
    4008203c:	d69f03e0 	eret

0000000040082040 <spin_lock>:
.global spin_unlock
.global spin_trylock


spin_lock:
    mov w1, #1                // w1 = 1 (表示锁定)
    40082040:	52800021 	mov	w1, #0x1                   	// #1
1:  ldaxr w2, [x0]            // 原子加载锁的状态到 w2，带有 Acquire 语义
    40082044:	885ffc02 	ldaxr	w2, [x0]
    cbnz w2, 1b               // 如果锁已被持有，继续自旋
    40082048:	35ffffe2 	cbnz	w2, 40082044 <spin_lock+0x4>
    stlxr w2, w1, [x0]        // 尝试原子存储 1 到锁变量，带有 Release 语义
    4008204c:	8802fc01 	stlxr	w2, w1, [x0]
    cbnz w2, 1b               // 如果存储失败（锁被其他处理器获取），继续自旋
    40082050:	35ffffa2 	cbnz	w2, 40082044 <spin_lock+0x4>
    dmb ish                   // 内存屏障，确保锁定操作完成
    40082054:	d5033bbf 	dmb	ish
    ret
    40082058:	d65f03c0 	ret

000000004008205c <spin_trylock>:
/*
 * when spinlock already taken, r1 will read 1 which is same with the
 * 'strex' failure return value, no extra convertion needed.
 */
spin_trylock:
    mov w1, #1                // w1 = 1 (表示锁定)
    4008205c:	52800021 	mov	w1, #0x1                   	// #1
    ldaxr w2, [x0]            // 原子加载锁的状态到 w2，带有 Acquire 语义
    40082060:	885ffc02 	ldaxr	w2, [x0]
    cbnz w2, 2f               // 如果锁已被持有，跳到标签2
    40082064:	350000c2 	cbnz	w2, 4008207c <spin_trylock+0x20>
    stlxr w2, w1, [x0]        // 尝试原子存储 1 到锁变量，带有 Release 语义
    40082068:	8802fc01 	stlxr	w2, w1, [x0]
    cbnz w2, 2f               // 如果存储失败（锁被其他处理器获取），跳到标签2
    4008206c:	35000082 	cbnz	w2, 4008207c <spin_trylock+0x20>
    dmb ish                   // 内存屏障，确保锁定操作完成
    40082070:	d5033bbf 	dmb	ish
    mov w0, #0                // 返回 0 表示获取锁成功
    40082074:	52800000 	mov	w0, #0x0                   	// #0
    ret
    40082078:	d65f03c0 	ret
2:  mov w0, #1                // 返回 1 表示获取锁失败
    4008207c:	52800020 	mov	w0, #0x1                   	// #1
    ret
    40082080:	d65f03c0 	ret

0000000040082084 <spin_unlock>:


spin_unlock:
    dmb ish                   // 内存屏障，确保之前的内存操作完成
    40082084:	d5033bbf 	dmb	ish
    mov w1, #0
    40082088:	52800001 	mov	w1, #0x0                   	// #0
    stlr w1, [x0]             // 原子存储 0 到锁变量，带有 Release 语义
    4008208c:	889ffc01 	stlr	w1, [x0]
    40082090:	d65f03c0 	ret
    40082094:	00000000 	udf	#0

0000000040082098 <_start>:
.section .text
.global _start

_start:

    msr daifset, #2   // 关闭所有中断
    40082098:	d50342df 	msr	daifset, #0x2

    adrp    x0, exception_vector_base
    4008209c:	f0ffffe0 	adrp	x0, 40081000 <tiny_printf+0x130>
    add     x0, x0, :lo12:exception_vector_base
    400820a0:	91200000 	add	x0, x0, #0x800
    msr     vbar_el1, x0
    400820a4:	d518c000 	msr	vbar_el1, x0
    dsb     sy      // 确保所有内存访问完成
    400820a8:	d5033f9f 	dsb	sy
    isb             // 确保所有指令都执行完成
    400820ac:	d5033fdf 	isb

    // 设置栈指针
    ldr x0, =_stack_top
    400820b0:	58000080 	ldr	x0, 400820c0 <_start+0x28>
    mov sp, x0
    400820b4:	9100001f 	mov	sp, x0

    // 调用 C 语言的 main 函数
    bl kernel_main
    400820b8:	97fff9e1 	bl	4008083c <kernel_main>

    // 死循环，防止返回
1:  b 1b
    400820bc:	14000000 	b	400820bc <_start+0x24>
    400820c0:	40085000 	.word	0x40085000
    400820c4:	00000000 	.word	0x00000000
